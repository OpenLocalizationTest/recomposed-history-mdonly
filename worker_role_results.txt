articles\cache-dotnet-how-to-use-in-role.md:Switch to the **Caching** tab, check the **Enable Caching** checkbox, and specify the desired caching options. When caching is enabled in a **Worker Role** or **ASP.NET Web Role**, the default configuration is **Co-located Role** caching with 30% of the memory of the role instances allocated for caching. A default cache is automatically configured, and additional named caches can be created if desired, and these caches will share the allocated memory.
articles\cache-dotnet-how-to-use-in-role.md:To configure a **Dedicated Role** cache cluster, add a **Cache Worker Role** to your project.
articles\cache-dotnet-how-to-use-in-role.md:When a **Cache Worker Role** is added to a project, the default configuration is **Dedicated Role** caching.
articles\cache-dotnet-how-to-use-service.md:Cache Service (Preview) gives you access to a secure, dedicated cache that is managed by Microsoft. A cache created using the Cache Service (Preview) is accessible from applications within Azure running on Azure Web Sites, Web & Worker Roles and Virtual Machines.
articles\cache-dotnet-how-to-use-service.md:A cache created using the Cache Service (Preview) is accessible from Azure applications running on Azure Web Sites, Web & Worker Roles and Virtual Machines. A NuGet package is provided that simplifies the configuration of cache client applications. 
articles\choose-web-site-cloud-service-vm.md:- Host web, middle-tier, and backend services on scalable web and worker roles. 
articles\choose-web-site-cloud-service-vm.md:- Host only the middle-tier and backend services on worker roles, keeping the front-end on Azure Web Sites. 
articles\choose-web-site-cloud-service-vm.md:[Cloud Services][] enable you to create highly-available, scalable web applications in a rich Platform as a Service (PaaS) environment. Unlike Web Sites, a cloud service is created first in a development environment, such as Visual Studio, before being deployed to Azure. Frameworks, such as PHP, require custom deployment steps or tasks that install the framework on role startup. The main advantage of Cloud Services is the ability to support more complex multitier architectures. A single cloud service could consist of a frontend web role and one or more worker roles. Each tier can be scaled independently. There is also an increased level of control over your web application infrastructure. For example, you can remote desktop onto the machines that are running the role instances. You can also script more advanced IIS and machine configuration changes that run at role startup, including tasks that require administrator control.
articles\choose-web-site-cloud-service-vm.md:<sup>1</sup> Web or worker roles can integrate MySQL-as-a-service through ClearDB's offerings, but not as part of the Management Portal workflow.
articles\cloud-services-continuous-delivery-use-vso.md:or a new ASP.NET MVC project. Make sure that the project targets .NET Framework 4 or 4.5, and if you are creating a cloud service project, add an ASP.NET MVC web role and a worker role, and choose Internet application for the web role. When prompted, choose **Internet Application**.
articles\cloud-services-dotnet-autoscaling-application-block.md:-   [Hosting the Autoscaling Application Block in a Worker Role][]
articles\cloud-services-dotnet-autoscaling-application-block.md:  [Hosting the Autoscaling Application Block in a Worker Role]: http://msdn.microsoft.com/en-us/library/hh680914(PandP.50).aspx
articles\cloud-services-dotnet-diagnostics.md:Azure Diagnostics enables you to collect diagnostic data from a worker role or web role running in Azure. You can use diagnostic data for debugging and troubleshooting, measuring performance, monitoring resource usage, traffic analysis and capacity planning, and auditing.
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:* How to create a Visual Studio cloud project with an ASP.NET MVC web role and two worker roles.
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:* How to publish the MVC project to an Azure Web Site if you prefer, and still use the worker roles in a Cloud Service.
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:* How to use the Azure Queue storage service for communication between tiers or between worker roles.
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:* How to scale an application by increasing the number of worker role instances.
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:4. [Building worker role A (email scheduler) for the Azure Email Service application][tut4]. How to build the back-end component that creates queue work items for sending emails, and test it locally.
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:5. [Building worker role B (email sender) for the Azure Email Service application][tut5]. How to build the back-end component that processes queue work items for sending emails, and test it locally.
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:If a server fails while sending out emails to a large list, you want to be able to spin up a new server easily and quickly, and you want the application to pick up where it left off without losing or duplicating any emails. An Azure Cloud Service web or worker role instance (a virtual machine) is automatically replaced if it fails. And Azure Storage queues and tables provide a means to implement server-to-server communication that can survive a failure without losing work.
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:An email service also must be able to handle spikes in workload, since sometimes you are sending emails to small lists and sometimes to very large lists.  In many hosting environments, you have to purchase and maintain sufficient hardware to handle the spikes in workload, and you're paying for all that capacity 100% of the time although you might only use it 5% of the time.  With Azure, you pay only for the amount of computing power that you actually need for only as long as you need it.  To scale up for a large mailing, you just change a configuration setting to increase the number of servers you have available to process the workload, and this can be done programmatically.  For example, you could configure the application so that if the number of work items waiting in the queue exceeds a certain number, Azure automatically spins up additional instances of the worker role that processes those work items.
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:The front-end stores email lists and messages to be sent to them in Azure tables. When an administrator schedules a message to be sent, a table row containing the scheduled date and other data such as the subject line is added to the `message` table. A worker role periodically scans the `message` table looking for messages that need to be sent (we'll call this worker role A). 
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:When worker role A finds a message needing to be sent, it does the following tasks:
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:A second worker role (worker role B) polls the queue for work items. When worker role B finds a work item, it processes the item by sending the email, and then it deletes the work item from the queue. The following diagram shows these relationships.
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:No emails are missed if worker role B goes down and has to be restarted, because a queue work item for an email isn't deleted until after the email has been sent. The back-end also implements table processing that prevents multiple emails from getting sent in case worker role A goes down and has to be restarted. In that case, multiple queue work items might be generated for a given destination email address. But for each destination email address, a row in the `message` table tracks whether the email has been sent. Depending on the timing of the restart and email processing, worker A uses this row to avoid creating a second queue work item, or worker B uses this row to avoid sending a second email.
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:Worker role B also polls a subscription queue for work items put there by the Web API service method for new subscriptions. When it finds one, it sends the confirmation email. 
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:The Azure Email Service application stores data in Azure Storage tables. Azure tables are a NoSQL data store, not a relational database like [Azure SQL Database](http://msdn.microsoft.com/en-us/library/windowsazure/ee336279.aspx). That makes them a good choice when efficiency and scalability are more important than data normalization and relational integrity. For example, in this application, one worker role creates a row every time a queue work item is created, and another one retrieves and updates a row every time an email is sent, which might become a performance bottleneck if a relational database were used. Additionally,  Azure tables are cheaper than Azure SQL.  For more information about Azure tables, see the resources that are listed at the end of [the last tutorial in this series][tut5].
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:The `message` table stores information about messages that are scheduled to be sent to a mailing list. Administrators create and edit rows in this table using web pages, and the worker roles use it to pass information about each email from worker role A to worker role B.
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:The partition key for the message table is the date the email is scheduled to be sent, in yyyy-mm-dd format. This optimizes the table for the query that is executed most often against this table, which selects rows that have `ScheduledDate` of today or earlier. However, it does creates a potential performance bottleneck, because Azure Storage tables have a maximum throughput of 500 entities per second for a partition.  For each email to be sent, the application writes a `message` table row, reads a row, and deletes a row. Therefore the shortest possible time for processing 1,000,000 emails scheduled for a single day is almost two hours, regardless of how many worker roles are added in order to handle increased loads. 
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:<li>"Pending" -- Worker role A has not yet started to create queue messages to schedule emails.</li>
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:<li>"Queuing" -- Worker role A has started to create queue messages to schedule emails.</li>
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:<li>"Processing" -- Worker role A has created queue work items for all emails in the list, but not all emails have been sent yet.</li>
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:<li>"Completed" -- Worker role B has finished processing all queue work items (all emails have been sent). Completed rows are archived in the <code>messagearchive</code> table, as explained later. We hope to make this property an <code>enum</code>  in the next release.</li></ul></td>
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:When worker role A creates a queue message for an email to be sent to a list, it creates an email row in the `message` table. When worker role B sends the email, it moves the email row to the `messagearchive` table and updates the `EmailSent` property to `true`. When all of the email rows for a message in Processing status have been archived, worker role A sets the status to Completed and moves the `message` row to the `messagearchive` table.
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:There is redundant data in these rows, which you would typically avoid in a relational database. But in this case you are trading some of the disadvantages of redundant data for the benefit of greater processing efficiency and scalability.  Because all of the data needed for an email is present in one of these rows, worker role B only needs to read one row in order to send an email when it pulls a work item off the queue.
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:One strategy for making sure that queries execute efficiently, especially if you have to search on fields other than `PartitionKey` and `RowKey`, is to limit the size of the table. The query in worker role A that checks to see if all emails have been sent for a message needs to find email rows in the `message` table that have `EmailSent` = false. The `EmailSent` value is not in the PartitionKey or RowKey, so this would not be an efficient query for a message with a large number of email rows. Therefore, the application moves email rows to the `messagearchive` table as the emails are sent. As a result, the query to check if all emails for a message have been sent only has to query the message table on `PartitionKey` and `RowKey` because if it finds any email rows for a message at all, that means there are unsent messages and the message can't be marked `Complete`. 
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:Azure queues facilitate communication between tiers of this multi-tier application, and between worker roles in the back-end tier. 
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:Queues are used to communicate between worker role A and worker role B in order to make the application scalable. Worker role A could create a row in the Message table for each email, and worker role B could scan the table for rows representing emails that haven't been sent, but you wouldn't be able to add additional instances of worker role B in order to divide up the work. The problem with using table rows to coordinate the work between worker role A and worker role B is that you have no way of ensuring that only one worker role instance will pick up any given table row for processing. Queues give you that assurance. When a worker role instance pulls a work item off a queue, the queue service makes sure that no other worker role instance can pull the same work item. This exclusive lease feature of Azure queues facilitates sharing a workload among multiple instances of a worker role.
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:The `AzureMailQueue` queue coordinates the sending of emails to email lists.  Worker role A places a work item on the queue for each email to be sent, and worker role B pulls a work item from the queue and sends the email. 
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:A queue work item contains a comma-delimited string that consists of the scheduled date of the message (partition key to the `message` table) and the `MessageRef` and `EmailAddress` values (row key to the `message` table) values, plus a flag indicating whether the item is created after the worker role went down and restarted, for example:
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:Worker role B uses these values to look up the row in the `message` table that contains all of the information needed to send the email. If the restart flag indicates a restart, worker B makes sure the email has not already been sent before sending it.
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:When traffic spikes, the Cloud Service can be reconfigured so that multiple instances of worker role B are instantiated, and each of them can independently pull work items off the queue.
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:The `AzureMailSubscribeQueue` queue coordinates the sending of subscription confirmation emails.  In response to a service method call, the service method places a work item on the queue.  Worker role B pulls the work item from the queue and sends the subscription confirmation email. 
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:A queue work item contains the subscriber GUID.  This value uniquely identifies an email address and the list to subscribe it to, which is all that worker role B needs to send a confirmation email. As explained earlier, this requires a query on a field that is not in the `PartitionKey` or `RowKey`, which is inefficient. To make the application more scalable, the `mailinglist` table would have to be restructured to include the subscriber GUID in the `RowKey`.
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:Costs are affected by the number of web and worker role instances you decide to maintain. In order to qualify for the [Azure Cloud Service 99.95% Service Level Agreement (SLA)](https://www.windowsazure.com/en-us/support/legal/sla/ "SLA"), you must deploy two or more instances of each role. One of the reasons you must run at least two role instances is because the virtual machines that run your application are restarted approximately twice per month for operating system upgrades. (For more information on OS Updates, see [Role Instance Restarts Due to OS Upgrades](http://blogs.msdn.com/b/kwill/archive/2012/09/19/role-instance-restarts-due-to-os-upgrades.aspx).) 
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:The work performed by the two worker roles in this sample is not time critical and so does not need the 99.5% SLA. Therefore, running a single instance of each worker role is feasible so long as one instance can keep up with the work load. The  web role instance is time sensitive, that is, users expect the web site to not have any down time, so a production application should have at least two instances of the web role.
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:<td>Worker role A (schedules emails to be sent)</td>
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:<td>Worker role B (sends emails)</td>
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:<td>1 million transactions per month at $0.10/million (Each query counts as a transaction; worker role A continuously queries tables for messages that need to be sent. The application is also configured to write diagnostic data to Azure Storage, and each time it does that is a transaction.)</td>
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:As you can see, role instances are a major component of the overall cost. Role instances incur a cost even if they are stopped; you must delete a role instance to not incur any charges. One cost saving approach would be to move all the code from worker role A and worker role B into one worker role. For these tutorials we deliberately chose to implement two worker instances in order to simplify scale out. The work that worker role B does is coordinated by the Azure Queue service, which means that you can scale out worker role B simply by increasing the number of role instances. (Worker role B is the limiting factor for high load conditions.) The work performed by worker role A is not coordinated by queues, therefore you cannot run multiple instances of worker role A. If the two worker roles were combined and you wanted to enable scale out, you would need to implement a mechanism for ensuring that worker role A tasks run in only one instance. (One such mechanism is provided by [CloudFx](http://nuget.org/packages/Microsoft.Experience.CloudFx "CloudFX"). See the [WorkerRole.cs sample](http://code.msdn.microsoft.com/windowsazure/CloudFx-Samples-60c3a852/sourcecode?fileId=57087&pathId=528472169).)
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:It is also possible to move all of the code from the two worker roles into the web role so that everything runs in the web role. However, performing background tasks in ASP.NET is not supported or considered robust, and this architecture would complicate scalability. For more information see [The Dangers of Implementing Recurring Background Tasks In ASP.NET](http://haacked.com/archive/2011/10/16/the-dangers-of-implementing-recurring-background-tasks-in-asp-net.aspx). See also [How to Combine a Worker and Web Role in Azure](http://www.31a2ba2a-b718-11dc-8314-0800200c9a66.com/2010/12/how-to-combine-worker-and-web-role-in.html) and [Combining Multiple Azure Worker Roles into an Azure Web Role](http://www.31a2ba2a-b718-11dc-8314-0800200c9a66.com/2012/02/combining-multiple-azure-worker-roles.html).
articles\cloud-services-dotnet-multi-tier-app-storage-1-overview.md:Another architecture alternative that would reduce cost is to use the [Autoscaling Application Block][autoscalingappblock] to automatically deploy worker roles only during scheduled periods, and delete them when work is completed. For more information on autoscaling, see the links at the end of [the last tutorial in this series][tut5].
articles\cloud-services-dotnet-multi-tier-app-storage-2-download-run.md:* How to scale the application by increasing the number of worker role instances.
articles\cloud-services-dotnet-multi-tier-app-storage-2-download-run.md:- [Add another worker role instance to handle increased load][]
articles\cloud-services-dotnet-multi-tier-app-storage-2-download-run.md:You can use the same procedure to configure settings for the worker roles, or you can propagate the web role settings to the worker roles by editing the configuration file. The following steps explain how to edit the configuration file. (This is still part of the manual method for setting storage credentials, which you don't have to do if you already propagated the settings to the worker roles by using the automatic method.)
articles\cloud-services-dotnet-multi-tier-app-storage-2-download-run.md:	In the `Role` elements for the two worker roles you'll see the same two connection strings.
articles\cloud-services-dotnet-multi-tier-app-storage-2-download-run.md:<div class="note"><p><strong>Note:</strong> If you don't want to use SendGrid, or can't use SendGrid, you can easily substitute your own email service. The code that uses SendGrid is isolated in two methods in worker role B.  [Tutorial 5][tut5] explains what you have to change in order to implement a different method of sending emails. If you want to do that, you can skip this procedure and continue with this tutorial; everything else in the application will work (web pages, email scheduling, etc.) except  for the actual sending of emails.</p></div>
articles\cloud-services-dotnet-multi-tier-app-storage-2-download-run.md:### Update SendGrid credentials in worker role properties
articles\cloud-services-dotnet-multi-tier-app-storage-2-download-run.md:Earlier in the tutorial when you set the storage account credentials for the web role and the two worker roles, you may have noticed that worker role B had three settings that were not in the web role or worker role A. You can use that same UI now to configure those three settings (select **Cloud** in the **Service Configuration** drop-down list).
articles\cloud-services-dotnet-multi-tier-app-storage-2-download-run.md:Earlier in the tutorial when you set the storage account credentials for the web role and the two worker roles, you set the credentials to use when you run the application locally. Now you need to set the storage account credentials to use when you run the application in the cloud.
articles\cloud-services-dotnet-multi-tier-app-storage-2-download-run.md:2. Verify that the web role and two worker role elements all define the same connection strings.
articles\cloud-services-dotnet-multi-tier-app-storage-2-download-run.md:<h2><a name="addRole"></a><span class="short-header">Add a Role Instance</span>Add another worker role instance to handle increased load</h2>
articles\cloud-services-dotnet-multi-tier-app-storage-2-download-run.md:Worker role B in this application is the limiting component under high load because it does the work of sending emails. (Worker role A just creates queue messages, which is not resource-intensive.) Because worker role B is not multi-threaded and does not have a large memory footprint, it's not a good candidate for scale up. Worker role B can scale linearly (that is, nearly double performance when you double the instances) by increasing the instance count. Increasing the number of compute instances is known as *scale out*. There is a cost for each instance, so you should only scale out when your application requires it. 
articles\cloud-services-dotnet-multi-tier-app-storage-2-download-run.md:You can scale out a web or worker role by updating the setting in the Visual Studio UI or by editing the *ServiceConfiguration.\*.cscfg* files directly. The instance count is specified in the **Configuration** tab of the role **Properties** window and in the `Instances` element in the *.cscfg* files. When you update the setting, you have to deploy the updated configuration file to make the change take effect. Alternatively, for transient increases in load, you can change the number of role instances in the Azure Management Portal. You can also configure the number of instances using the Azure Management API. Finally, you can use the [Autoscaling Application Block][autoscalingappblock] to automatically scale out to meet increased load. For more information on autoscaling, see the links at the end of [the last tutorial in this series][tut5].
articles\cloud-services-dotnet-multi-tier-app-storage-2-download-run.md:In this section of the tutorial you'll scale out worker role B by using the management portal, but first you'll see how it's done in Visual Studio.
articles\cloud-services-dotnet-multi-tier-app-storage-2-download-run.md:1. Increase the number of instances for worker role B, and then click **Save**.
articles\cloud-services-dotnet-multi-tier-app-storage-2-download-run.md:[Add another worker role instance to handle increased load]: #addRole
articles\cloud-services-dotnet-multi-tier-app-storage-3-web-role.md:* How to create a solution that contains a Cloud Service project with a web role and a worker role. 
articles\cloud-services-dotnet-multi-tier-app-storage-3-web-role.md:You begin by creating a Visual Studio solution with a project for the web front-end and a project for one of the back-end Azure worker roles. You'll add the second worker role later. 
articles\cloud-services-dotnet-multi-tier-app-storage-3-web-role.md:### Create a cloud service project with a web role and a worker role
articles\cloud-services-dotnet-multi-tier-app-storage-3-web-role.md:	>[WACOM.NOTE] The downloaded code that you use for this tutorial is MVC 4 but you can't create an MVC 4 Web Role in Visual Studio 2013 using instructions written for Visual Studio 2012. For Visual Studio 2013 do the following: (1) Skip the steps here for creating the web role and do the step for the worker role. (2) After the worker role is created, right-click the solution in **Solution Explorer**, and click **Add** -- **New Project**. In the left pane of the **Add New Project** dialog expand **Web** and select **Visual Studio 2012**.  (3) Choose **ASP.NET MVC 4 Web Application**, name the project **MvcWebRole**, and then click **OK**. (4) In the **New ASP.NET Project** dialog box, select the **Internet Application** template. (5) Right-click **Roles** under **AzureEmailService** in **Solution Explorer**, and then click **Add** - **Web Role Project in Solution**. (6) In the **Associate with Role Project** box, select the **MvcWebRole** project, and then click **OK**.
articles\cloud-services-dotnet-multi-tier-app-storage-3-web-role.md:8. Follow the same procedure to add a **Worker Role**, name it WorkerRoleA, and then click **OK**.
articles\cloud-services-dotnet-multi-tier-app-storage-3-web-role.md:	![New Azure Cloud Project dialog box - adding a worker role][mtas-new-cloud-service-add-worker-a]
articles\cloud-services-dotnet-multi-tier-app-storage-3-web-role.md:You are going to enter settings for your test storage account, which you will use while running the project locally.  To add a new setting you have to add it for both cloud and local, but you can change the cloud value later. You'll add the same settings for worker role A later.
articles\cloud-services-dotnet-multi-tier-app-storage-3-web-role.md:	The `HttpGet Edit` method validates that the retrieved message is in `Pending` status so that the user can't change a message once worker role B has begun processing it.  Similar code is in the `HttpPost Edit` method and the `Delete` and `DeleteConfirmed` methods.
articles\cloud-services-dotnet-multi-tier-app-storage-3-web-role.md:	This helps prevent the user from making changes to a message after worker role A has begun to process it.
articles\cloud-services-dotnet-multi-tier-app-storage-3-web-role.md:* When you create the solution, create the **ASP.NET MVC 4 Web Application** project first, and then add to the solution a **Azure Cloud Service** project with a worker role.
articles\cloud-services-dotnet-multi-tier-app-storage-3-web-role.md:In the [next tutorial][nexttutorial] you'll configure and program worker role A, the worker role that schedules emails.
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:<properties linkid="develop-net-tutorials-multi-tier-web-site-4-worker-role-a" urlDisplayName="develop-net-tutorials-multi-tier-web-site-4-worker-role-a" pageTitle="ASP.NET Multi-tier Web Application with Azure - Step 4: Worker role A" metaKeywords="Azure tutorial, .NET multi-tier app, multi-tier architecture" description="The fourth tutorial in a series that teaches how to configure your computer for Azure development and deploy the Email Service app." metaCanonical="" services="cloud-services,storage" documentationCenter=".NET" title="Building worker role A (email scheduler) for the Azure Email Service application - 4 of 5." authors="tdykstra,riande" solutions="" manager="wpickett" editor="mollybos" />
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:# Building worker role A (email scheduler) for the Azure Email Service application - 4 of 5. 
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:* How to add work items to a queue for processing by another worker role.
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:* How to test a worker role that uses Azure Storage tables, by using Azure Storage Explorer.
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:You already created the worker role A project when you created the cloud service project. So all you have to do now is program the worker role and configure it to use your Azure Storage account.
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:You need a reference to the web project because that is where the entity classes are defined. You'll use the same entity classes in worker role B to read and write data in the Azure tables that the application uses.
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:**Note:** In a production application you wouldn't set a reference to a web project from a worker role project, because this results in referencing a number of dependent assemblies that you don't want or need in the worker role. Normally you would keep shared model classes in a class library project, and both web and worker role projects would reference the class library project. To keep the solution structure simple, model classes are stored in the web project for this tutorial.
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:Worker role A creates the `SendEmail` rows in the `Message` table, and worker Role B reads those rows in order to get the information it needs for sending emails. The following image shows a subset of properties for two `Message` rows and three `SendEmail` rows in the `Message` table.
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:* They provide all of the information that worker role B needs in order to send a single email.
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:* They track whether an email has been sent, in order to prevent duplicates from being sent in case a worker role restarts after a failure.
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:* They make it possible for worker role A to determine when all emails for a message have been sent, so that it can be marked as `Complete`.
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:For reading and writing the `SendEmail` rows, a model class is required.  Since it must be accessible to both worker role A and worker role B, and since all of the other model classes are defined in the web project, it makes sense to define this one in the web project also. 
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:<h2><a name="addcode"></a><span class="short-header">Add worker role code</span>Add code that runs when the worker role starts</h2>
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:	This is the default template code for the worker role. There is an `OnStart` method in which you can put initialization code that runs only when an instance of the worker role starts, and a `Run` method that is called after the `OnStart` method completes. You'll replace this code with your own initialization and run code.
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:	![Add existing item to Worker Role A][mtas-worker-a-add-existing]
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:	The `OnStop` method is called when the worker role is shutting down for one of the following reasons:
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:	* Azure needs to reboot the virtual machine (the web role or worker role instance) or the physical machine that hosts the virtual machine.
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:	Notice that all of the work is done in an infinite loop in a `while` block, and all of the code in the `while` block is wrapped in a `try`-`catch` block to prevent an unhandled exception. If an unhandled exception occurs, Azure will raise the [UnhandledException](http://msdn.microsoft.com/en-us/library/system.appdomain.unhandledexception.aspx) event, the worker process is terminated, and the role is taken offline. The worker role will be restarted by Azure, but this takes several minutes. The `try` block calls `TraceError` to record the error and then sleeps for 60 seconds so that if the error is persistent the error message won't be repeated too many times.  In a production application you might send an email to an administrator in the `try` block.
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:	If a message is in `Pending` status, processing has not yet begun; if it is in `Queuing` status, processing did begin earlier but was interrupted before all queue messages were created. In that case an additional check has to be done in worker role B when it is sending each email to make sure the email hasn't already been sent. That is the purpose of the `restartFlag` variable.
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:	The `ProcessMessage` method gets all of the email addresses for the destination email list, and creates a queue work item for each email address. As it creates queue work items, it also creates `SendEmail` rows in the `Message` table. These rows provide worker role B with the information it needs to send emails and includes an `EmailSent` property that tracks whether each email has been sent.
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:                // an exception might happen if this worker role went 
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:	The code first gets the mailing list row from the `mailinglist` table for the destination mailing list.  This row has the "from" email address which needs to be provided to worker role B for sending emails.
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:	Next, the code creates a `SendEmail` row in the `message` table. This row contains the information that worker role B will use to send an email. The row is created with the `EmailSent` property set to `false`.
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:	The code uses an "upsert" operation because the row might already exist if worker role A is restarting after a failure.
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:	The last task to be done for each email address is to create the queue work item that will trigger worker role B to send an email. The queue work item contains the partition key and row key value of the `SendEmail` row that was just created, plus the restart flag that was set earlier. The `SendEmail` row contains all of the information that worker role B needs in order to send an email.
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:If you didn't already configure the storage account credentials for worker role A when you did that for the web role, do it now. 
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:<h2><a name="testing"></a><span class="short-header">Testing</span>Testing worker role A</h2>
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:	No emails will be sent until you implement worker role B, but you'll use the same test data for testing worker role B.
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:11. Double-click a row that has an email address in the row key, to see the contents of the `SendEmail` row that worker role A created.
articles\cloud-services-dotnet-multi-tier-app-storage-4-worker-role-a.md:You have now built worker role A and verified that it creates the queue messages and table rows that worker role B needs in order to send emails. In the [next tutorial][tut5], you'll build and test worker role B.
articles\cloud-services-dotnet-multi-tier-app-storage-5-worker-role-b.md:<properties linkid="develop-net-tutorials-multi-tier-web-site-5-worker-role-b" urlDisplayName="Step 5: Worker Role B" pageTitle="ASP.NET Multi-tier Web Application with Azure - Step 5: Worker role B" metaKeywords="Azure tutorial, adding working role cloud service, C# worker role" description="The fifth tutorial in a series that teaches how to configure your computer for Azure development and deploy the Email Service app." metaCanonical="" services="cloud-services,storage" documentationCenter=".NET" title="Building worker role B (email sender) for the Azure Email Service application - 5 of 5." authors="tdykstra,riande" solutions="" manager="wpickett" editor="mollybos" />
articles\cloud-services-dotnet-multi-tier-app-storage-5-worker-role-b.md:# Building worker role B (email sender) for the Azure Email Service application - 5 of 5. 
articles\cloud-services-dotnet-multi-tier-app-storage-5-worker-role-b.md:* How to add a worker role to a cloud service project.
articles\cloud-services-dotnet-multi-tier-app-storage-5-worker-role-b.md:<h2><a name="addworkerrole"></a><span class="short-header">Add worker role B</span>Add worker role B project to the solution</h2>
articles\cloud-services-dotnet-multi-tier-app-storage-5-worker-role-b.md:1. In Solution Explorer, right-click the cloud service project, and choose **New Worker Role Project**.
articles\cloud-services-dotnet-multi-tier-app-storage-5-worker-role-b.md:	![New worker role project menu][mtas-new-worker-role-project]
articles\cloud-services-dotnet-multi-tier-app-storage-5-worker-role-b.md:3. In the **Add New Role Project** dialog box, select **C#**, select **Worker Role**, name the project WorkerRoleB, and click **Add**. 
articles\cloud-services-dotnet-multi-tier-app-storage-5-worker-role-b.md:You need a reference to the web project because that is where the entity classes are defined. You'll use the entity classes in worker role B to read and write data in the Azure tables that the application uses.
articles\cloud-services-dotnet-multi-tier-app-storage-5-worker-role-b.md:>[WACOM.NOTE] With Visual Studio 2013 you can skip this section because the current Azure Storage package is installed in the new worker role project.
articles\cloud-services-dotnet-multi-tier-app-storage-5-worker-role-b.md:Like worker role A, worker role B needs storage account credentials to work with tables, queues, and blobs. In addition, in order to send email, the worker role needs to have credentials to embed in calls to the SendGrid service. And in order to construct an unsubscribe link to include in emails that it sends, the worker role needs to know the URL of the application. These values are stored in project settings.
articles\cloud-services-dotnet-multi-tier-app-storage-5-worker-role-b.md:8. Choose the same **Subscription** and **Account name** that you chose for the web role and worker role A.
articles\cloud-services-dotnet-multi-tier-app-storage-5-worker-role-b.md:	Next, you create and configure the three new settings that are only used by worker role B.
articles\cloud-services-dotnet-multi-tier-app-storage-5-worker-role-b.md:### Add code that runs when the worker role starts
articles\cloud-services-dotnet-multi-tier-app-storage-5-worker-role-b.md:	![Add existing item to Worker Role B][mtas-worker-b-add-existing]
articles\cloud-services-dotnet-multi-tier-app-storage-5-worker-role-b.md:	As you already saw in worker role A, the `OnStart` method initializes the context classes that you need in order to work with Azure storage entities. It also makes sure that all of the tables, queues, and blob containers you need in the `Run` method exist.  
articles\cloud-services-dotnet-multi-tier-app-storage-5-worker-role-b.md:	The difference compared to worker role A is the addition of the blob container and the subscribe queue among the resources to create if they don't already exist. You'll use the blob container to get the files that contain the HTML and plain text for the email body. The subscribe queue is used for sending subscription confirmation emails.
articles\cloud-services-dotnet-multi-tier-app-storage-5-worker-role-b.md:            Trace.TraceInformation("Initializing storage account in worker role B");
articles\cloud-services-dotnet-multi-tier-app-storage-5-worker-role-b.md:	The `Run` method processes work items from two queues: the queue used for messages sent to email lists (work items created by worker role A), and the queue used for subscription confirmation emails (work items created by the subscribe API method in the MvcWebRole project).
articles\cloud-services-dotnet-multi-tier-app-storage-5-worker-role-b.md:	This code runs in an infinite loop until the worker role is shut down. If a work item is found in the main queue, the code processes it and then checks the subscribe queue. 
articles\cloud-services-dotnet-multi-tier-app-storage-5-worker-role-b.md:	When a queue item is pulled from the queue by the [GetMessage][]  method, that queue item becomes invisible for 30 seconds to all other worker and web roles accessing the queue. This is what ensures that only one worker role instance will pick up any given queue message for processing. You can explicitly set this *exclusive lease* time (the time the queue item is invisible) by passing a  [visibility timeout](http://msdn.microsoft.com/en-us/library/windowsazure/ee758454.aspx) parameter to the  `GetMessage` method. If the worker role could take more than 30 seconds to process a queue message, you should increase the exclusive lease time to prevent other role instances from processing the same message. 
articles\cloud-services-dotnet-multi-tier-app-storage-5-worker-role-b.md:	On the other hand, you don't want to set the exclusive lease time to an excessively large value. For example, if the exclusive lease time is set to 48 hours and your worker role unexpectedly shuts down after dequeuing a message, another worker role would not be able to process the message for 48 hours. The exclusive lease maximum is 7 days.
articles\cloud-services-dotnet-multi-tier-app-storage-5-worker-role-b.md:<h2><a name="testing"></a><span class="short-header">Testing</span>Testing Worker Role B</h2>
articles\cloud-services-dotnet-multi-tier-app-storage-5-worker-role-b.md:2. Go to the **Messages** page to see the message you created to test worker role A. After a minute or so, refresh the web page and you will see that the row has disappeared from the list because it has been archived.
articles\cloud-services-dotnet-multi-tier-app-using-service-bus-queues.md:<properties linkid="dev-net-e2e-multi-tier" urlDisplayName="Multi-Tier Application" pageTitle=".NET Multi-Tier Application - Azure Tutorial" metaKeywords="Azure Service Bus queue tutorial, Azure queue tutorial, Azure worker role tutorial, Azure .NET queue tutorial, Azure C# queue tutorial, Azure C# worker role tutorial" description="A tutorial that helps you develop a multi-tier app in Azure that uses Service Bus queues to communicate between tiers. Samples in .NET." metaCanonical="" services="cloud-services,service-bus" documentationCenter=".NET" title=".NET Multi-Tier Application Using Service Bus Queues" authors="sethm" solutions="" manager="dwrede" editor="mattshel" />
articles\cloud-services-dotnet-multi-tier-app-using-service-bus-queues.md:    and worker roles.
articles\cloud-services-dotnet-multi-tier-app-using-service-bus-queues.md:the worker role. This example uses Service Bus brokered messaging for
articles\cloud-services-dotnet-multi-tier-app-using-service-bus-queues.md:<h2><span class="short-header">Create worker role</span>Create the worker role</h2>
articles\cloud-services-dotnet-multi-tier-app-using-service-bus-queues.md:You will now create the worker role that processes the order
articles\cloud-services-dotnet-multi-tier-app-using-service-bus-queues.md:submissions. This example uses the **Worker Role with Service Bus Queue** Visual Studio project template. First, you will use Server Explorer in Visual Studio to obtain the required credentials.
articles\cloud-services-dotnet-multi-tier-app-using-service-bus-queues.md:5.  Click **Add**, and then click **New Worker Role Project**. The **Add New Role Project** dialog appears.
articles\cloud-services-dotnet-multi-tier-app-using-service-bus-queues.md:6.  In the **Add New Role Project dialog**, click **Worker Role with Service Bus Queue**, as in the following figure:
articles\cloud-services-dotnet-multi-tier-app-using-service-bus-queues.md:    application as you did earlier, by pressing F5. Note that the message count does not increment, because the worker role processes items from the queue and marks them as complete. You can see the trace output of your
articles\cloud-services-dotnet-multi-tier-app-using-service-bus-queues.md:    worker role by viewing the Azure Compute Emulator UI. You
articles\cloud-services-dotnet-multi-tier-app-using-service-bus-queues.md:2. When you create the worker role, create it in a new, separate solution, similar to the original instructions for the web role. Now however, you're creating just the worker role in the cloud service project. Then follow the same directions for creating the worker role.
articles\cloud-services-dotnet-use-performance-counters.md:There are many performance counters that you can collect, the following example shows several performance counters that are recommended for web and worker role monitoring. 
articles\cloud-services-dotnet-use-performance-counters.md:		<!-- Use the Process(WaWorkerHost) category counters in a worker role.
articles\cloud-services-dotnet-use-performance-counters.md:In addition to the pre-defined performance counters, you can add your own custom performance counters to monitor web or worker roles.  Custom performance counters may be used to track and monitor application-specific behavior and can be created or deleted in a startup task, web role, or worker role with elevated permissions.
articles\cloud-services-how-to-appdynamics.md:	You need one agent license for each role instance that you wish to monitor. For example, a site running 2 Web role instances and 2 Worker role instances requires 4 agent licenses.
articles\cloud-services-how-to-appdynamics.md:2. If you created a new project, add the Web role and/or Worker role projects to the solution.
articles\cloud-services-how-to-appdynamics.md:3. To each Web and Worker role project that you want to monitor add the downloaded .NET Agent .msi file. 
articles\cloud-services-how-to-appdynamics.md:4. To each Web and Worker role project that you want to monitor add a text file named startup.cmd and paste the following lines in it:
articles\cloud-services-how-to-appdynamics.md:5. For each Web and Worker role that you want to monitor, set the **Copy to Output Directory** property for the AppDynamics agent .msi file and for the startup.cmd file to **Copy Always**.
articles\cloud-services-how-to-configure.md:5. In **operating system settings**, you can change the operating system family or version for role instances (virtual machines), or choose **Automatic** to resume automatic updates of the current operating system version. The operating system settings apply to web roles and worker roles, but do not affect VM roles that were added to hosted services in the previous Azure Management Portal.
articles\cloud-services-how-to-scale.md:On the Scale page of the Azure Management Portal, you can manually scale your application or you can set parameters to automatically scale it. You can scale applications that are running Web Roles, Worker Roles, or Virtual Machines. To scale an application that is running instances of Web Roles or Worker Roles, you add or remove role instances to accommodate the work load.
articles\cloud-services-how-to-scale.md:- [Manually scale an application running Web Roles or Worker Roles](#manualscale)
articles\cloud-services-how-to-scale.md:- [Automatically scale an application running Web Roles, Worker Roles, or Virtual Machines](#autoscale)
articles\cloud-services-how-to-scale.md:<h2><a id="manualscale"></a>Manually scale an application running Web Roles or Worker Roles</h2>
articles\cloud-services-how-to-scale.md:<h2><a id="autoscale"></a>Automatically scale an application running Web Roles, Worker Roles, or Virtual Machines</h2>
articles\cloud-services-nodejs-chat-app-socketio.md:2. Change directories to the **c:\\node** directory and then enter the following commands to create a new solution named **chatapp** and a worker role named **WorkerRole1**:
articles\cloud-services-nodejs-chat-app-socketio.md:<p>For simplicity, this sample is limited to chatting between users connected to the same instance. This means that if the cloud service creates two worker role instances, users will only be able to chat with others connected to the same worker role instance. To scale the application to work with multiple role instances, you could use a technology like Service Bus to share the Socket.IO store state across instances. For examples, see the Service Bus Queues and Topics usage samples in the <a href="https://github.com/WindowsAzure/azure-sdk-for-node">Azure SDK for Node.js GitHub repository</a>.</p>
articles\cloud-services-nodejs-chat-app-socketio.md:  [Hosting the Chat Example in a Worker Role]: #hostingthechatexampleinawebrole
articles\cloud-services-nodejs-configure-ssl-certficate-worker-role.md:<properties linkid="dev-nodejs-enablesslworker" urlDisplayName="Enable SSL worker role" pageTitle="Configure SSL for a cloud service (Node.js) worker role" metaKeywords="Node.js Azure SSL, Node.js Azure, SSL worker role" description="" metaCanonical="" services="cloud-services" documentationCenter="Node.js" title="Configuring SSL for a Node.js Application in an Azure Worker Role" authors="" solutions="" manager="" editor="" />
articles\cloud-services-nodejs-configure-ssl-certficate-worker-role.md:# Configuring SSL for a Node.js Application in an Azure Worker Role
articles\cloud-services-nodejs-configure-ssl-certficate-worker-role.md:to specify an HTTPS endpoint for a Node.js application hosted as an Azure Cloud Service in a worker role.
articles\cloud-services-nodejs-configure-ssl-certficate-worker-role.md:	<p>The steps in this article only apply to node applications hosted as an Azure Cloud Service in a worker role.</p>
articles\cloud-services-nodejs-configure-ssl-certficate-worker-role.md:3.  Add a worker role to your service using **Add-AzureNodeWorkerRole** cmdlet:
articles\cloud-services-nodejs-configure-ssl-certficate-worker-role.md:When a Node.js application is deployed to a worker role, the server certificate and SSL connection are managed by Node.exe. To handle SSL traffic, you must use the 'https' module instead of 'http'. Perform the following steps to add the SSL certificate to your project, and then modify the application to use the certificate.
articles\cloud-services-nodejs-configure-ssl-certificate.md:[Configuring SSL for a Node.js Application in an Azure Worker Role]
articles\cloud-services-nodejs-configure-ssl-certificate.md:  [Configuring SSL for a Node.js Application in an Azure Worker Role]: /en-us/develop/nodejs/common-tasks/enable-ssl-worker-role/
articles\cloud-services-performance-testing-visual-studio-profiler.md:You can use these instructions with an existing project or with a new project.  If you create a new project to try the techniques described below, choose a C# **Azure Cloud Service** project, and select a **Web Role** and a **Worker Role**.
articles\cloud-services-performance-testing-visual-studio-profiler.md:a lot of time and demonstrates some obvious performance problem. For example, add the following code to a worker role project:
articles\cloud-services-performance-testing-visual-studio-profiler.md:Call this code from the Run method in the worker role's RoleEntryPoint-derived class.
articles\cloud-services-performance-testing-visual-studio-profiler.md:For a worker role, find the WaWorkerHost.exe process.
articles\cloud-services-performance-testing-visual-studio-profiler.md: If there are multiple worker role processes in your application, you need to use the processID to distinguish them. You can query the processID programmatically by accessing the Process object. For example, if you add this code to the Run method of the RoleEntryPoint-derived class in a role, you can look at the
articles\cloud-services-performance-testing-visual-studio-profiler.md:Open the worker role log console window in the Compute Emulator UI by clicking on the console window's title bar. You can see the process ID in the log.
articles\cloud-services-performance-testing-visual-studio-profiler.md:Instrumenting Azure binaries in the emulator is not supported in the Visual Studio 2010 profiler, but if you want to test memory allocation, you can choose that option when profiling. You can also choose concurrency profiling, which helps you determine whether threads are wasting time competing for locks, or tier interaction profiling, which helps you track down performance problems when interacting between tiers of an application, most frequently between the data tier and a worker role.  You can view the database queries that your app generates and use the profiling data to improve your use of the database. For information about tier interaction profiling, see [Walkthrough: Using the Tier Interaction Profiler in Visual Studio Team System 2010][3].
articles\cloud-services-php-create-web-role.md:<properties linkid="develop-php-common-tasks-create-web-and-worker-roles" urlDisplayName="Create Web and Worker Roles" pageTitle="Create Web and Worker Roles" metaKeywords="" description="" metaCanonical="" services="" documentationCenter="PHP" title="How to create PHP web and worker roles" authors="bswan" solutions="" manager="paulettm" editor="mollybos" />
articles\cloud-services-php-create-web-role.md:#How to create PHP web and worker roles
articles\cloud-services-php-create-web-role.md:This guide will show you how to create PHP web or worker roles in a Windows development environment, choose a specific version of PHP from the "built-in" versions available, change the PHP configuration, enable extensions, and finally, how to deploy to Azure. It also describes how to configure a web or worker role to use a PHP runtime (with custom configuration and extensions) that you provide.
articles\cloud-services-php-create-web-role.md:* [What are PHP web and worker roles?](#WhatIs)
articles\cloud-services-php-create-web-role.md:* [How to: Add PHP Web and worker roles](#AddRole)
articles\cloud-services-php-create-web-role.md:##<a name="WhatIs"></a>What are PHP web and worker roles?
articles\cloud-services-php-create-web-role.md:Azure provides three compute models for running applications: [Azure Web Sites][execution model-web sites], [Azure Virtual Machines][execution model-vms], and [Azure Cloud Services][execution model-cloud services]. All three models support PHP. Cloud Services, which include web and worker roles, provide *Platform as a Service (PaaS)*. Within a cloud service, a web role provides a dedicated Internet Information Services (IIS) web server to host front-end web applications, while a worker role can run asynchronous, long-running or perpetual tasks independent of user interaction or input.
articles\cloud-services-php-create-web-role.md:The first step in creating a PHP web or worker role is to create an Azure Service project. an Azure Service project serves as a logical container for web and worker roles, and contains the project's [service definition (.csdef)] and [service configuration (.cscfg)] files. 
articles\cloud-services-php-create-web-role.md:This command will create a new directory (`myProject`) to which you can add web and worker roles.
articles\cloud-services-php-create-web-role.md:##<a name="AddRole"></a>How to: Add PHP web or worker roles
articles\cloud-services-php-create-web-role.md:For a worker role, use this command:
articles\cloud-services-php-create-web-role.md:<p>The <code>roleName</code> parameter is optional. If it is omitted, the role name will be automatically generated. The first web role created will be <code>WebRole1</code>, the second <code>WebRole2</code>, and so on. The first worker role created will be <code>WorkerRole1</code>, the second <code>WorkerRole2</code>, and so on.</p> 
articles\cloud-services-php-create-web-role.md:When you add a PHP web or worker role to a project, the project's configuration files are modified so that PHP will be installed on each web or worker instance of your application when it is deployed. To see the version of PHP that will be installed by default, run the following command:
articles\cloud-services-php-create-web-role.md:1. Add a new folder, named `php`, to the `bin` directory of your web role. For a worker role, add it to the role's root directory.
articles\cloud-services-php-create-web-role.md:In some cases, instead of selecting a built-in PHP runtime and configuring it as described above, you may want to provide your own PHP runtime. For example, you can use the same PHP runtime in a web or worker role that you use in your development environment, making it easier to ensure that application will not change behavior in your production environment.
articles\cloud-services-php-create-web-role.md:1. Create an Azure Service project and add a PHP web role as described in the [How to: Create a cloud services project](#CreateProject) and [How to: Add PHP web or worker roles](#AddRole) sections above.
articles\cloud-services-php-create-web-role.md:<h3><a name="OwnPHPWorkerRole"></a>Configuring a worker role to use your own PHP runtime</h3>
articles\cloud-services-php-create-web-role.md:To configure a worker role to use a PHP runtime that you provide, follow the steps below.
articles\cloud-services-php-create-web-role.md:1. Create an Azure Service project and add a PHP worker role as described in the [How to: Create a cloud services project](#CreateProject) and [How to: Add PHP web or worker roles](#AddRole) sections above.
articles\cloud-services-php-create-web-role.md:2. Create a `php` folder in the worker role's root directory, then add your PHP runtime (all binaries, configuration files, subfolders, etc.) to the `php` folder.
articles\cloud-services-php-create-web-role.md:3. (OPTIONAL) If your PHP runtime uses [Microsoft Drivers for PHP for SQL Server][sqlsrv drivers], you will need to configure your worker role to install [SQL Server Native Client 2012][sql native client] when it is provisioned. To do this, add the `sqlncli.msi` installer to the worker role's root directory. You can download the installer here: [sqlncli.msi x64 installer]. The startup script described in the next step will silently run the installer when the role is provisioned. If your PHP runtime does not use the Microsoft Drivers for PHP for SQL Server, you can remove the following line from the script shown in the next step:
articles\cloud-services-php-create-web-role.md:4. The next step is to define a startup task that adds your `php.exe` executable to the worker role's PATH environment variable when the role is provisioned. To do this, open the `setup_worker.cmd` file (in the worker role's root directory) in a text editor and replace its contents with the following script:
articles\cloud-services-php-create-web-role.md:5. Add your application files to your worker role's root directory.
articles\cloud-services-php-how-to-use-service-management.md:In this guide, you will use service features which can be called within a PHP application locally, or in code running within an Azure web role, worker role, or web site.
articles\cloud-services-what-is.md:By creating a cloud service, you can deploy a multi-tier application in Azure, defining multiple roles to distribute processing and allow flexible scaling of your application. A cloud service consists of one or more web roles and/or worker roles, each with its own application files and configuration.
articles\cloud-services-what-is.md:>- **worker role:** Applications hosted within worker roles can run asynchronous, long-running or perpetual tasks independent of user interaction or input.
articles\command-line-tools.md:Azure cloud services are applications and services hosted on web roles and worker roles. The following commands can be used to manage Azure cloud services.
articles\dotnet-develop-multitenant-applications.md:- Web Services in Worker Roles
articles\dotnet-develop-multitenant-applications.md:	- Worker Roles. that typically process data on the backend of an application.
articles\dotnet-develop-multitenant-applications.md:- Worker roles allow you to provision and de-provision per tenant resources (such as when a new tenant signs-up or cancels), collect metrics for metering use, and manage scale following a certain schedule or in response to the crossing of thresholds of key performance indicators. This same role may also be used to push out updates and upgrades to the solution. 
articles\fundamentals-application-models.md:<properties umbracoNaviHide="0" pageTitle="Application Model" metaKeywords="Azure, Azure, application model, Azure application model, development model, Azure development model, hosted service, Azure hosted service, web role, worker role" description="Learn about the Azure hosted service application model. Understand core concepts, design considerations, defining and configuring your application, and scaling." linkid="dev-net-fundamentals-application-model" urlDisplayName="Application Model" headerExpose="" footerExpose="" disqusComments="1" title="Application Model" authors="" />
articles\fundamentals-application-models.md:Like the other Azure compute options, Cloud Services relies on VMs. The technology provides two slightly different VM options: instances of *web roles* run a variant of Windows Server with IIS, while instances of *worker roles* run the same Windows Server variant without IIS. A Cloud Services application relies on some combination of these two options. 
articles\fundamentals-application-models.md:For example, a simple application might use just a web role, while a more complex application might use a web role to handle incoming requests from users, then pass the work those requests create to a worker role for processing. (This communication could use Service Bus or Azure Queues.)
articles\fundamentals-application-models.md:With Cloud Services, you don't create virtual machines. Instead, you provide a configuration file that tells Azure how many of each you'd like, such as three web role instances and two worker role instances, and the platform creates them for you.  You still choose what size those VMs should be'the options are the same as with Azure VMs'but you don't explicitly create them yourself. If your application needs to handle a greater load, you can ask for more VMs, and Azure will create those instances. If the load decreases, you can shut those instances down and stop paying for them.
articles\fundamentals-application-models.md:Cloud Services also provides monitoring. Like Azure Virtual Machines, it will detect a failed physical server and restart the VMs that were running on that server on a new machine. But Cloud Services also detects failed VMs and applications, not just hardware failures. Unlike Virtual Machines, it has an agent inside each web and worker role, and so it's able to start new VMs and application instances when failures occur.
articles\fundamentals-application-models.md:The PaaS nature of Cloud Services has other implications, too. One of the most important is that applications built on this technology should be written to run correctly when any web or worker role instance fails. To achieve this, a Cloud Services application shouldn't maintain state in the file system of its own VMs. Unlike VMs created with Azure Virtual Machines, writes made to Cloud Services VMs aren't persistent; there's nothing like a Virtual Machines data disk. Instead, a Cloud Services application should explicitly write all state to SQL Database, blobs, tables, or some other external storage. Building applications this way makes them easier to scale and more resistant to failure, both important goals of Cloud Services.
articles\fundamentals-application-models.md:- Because Cloud Services offers both web roles and worker roles, it's a better choice than Web Sites for multi-tier applications that need separate VMs for their business logic.
articles\nodejs-specify-node-version-azure-apps.md:<p>If you are hosting your application in an Azure Cloud Service (web or worker role,) and it is the first time you have deployed the application, Azure will attempt to use the same version of Node.js as you have installed on your development environment if it matches one of the default versions available on Azure.</p>
articles\service-bus-php-how-to-use-queues.md:In this guide, you will use service features which can be called within a PHP application locally, or in code running within an Azure web role, worker role, or web site.
articles\service-bus-php-how-to-use-topics-subscriptions.md:In this guide, you will use service features which can be called within a PHP application locally, or in code running within an Azure web role, worker role, or web site.
articles\set-up-hybrid-cluster-microsoft-hpc-pack-2012-sp1.md:This tutorial shows you how to use Microsoft HPC Pack 2012 R2 and Azure to set up a small, hybrid high performance computing (HPC) cluster. The cluster will consist of an on-premises head node (a computer running the Windows Server operating system and HPC Pack) and some compute nodes you deploy on-demand as worker role instances in an Azure cloud service. You can then run compute jobs on the hybrid cluster.
articles\set-up-hybrid-cluster-microsoft-hpc-pack-2012-sp1.md:- Create an Azure cloud service in which Azure nodes (worker role instances) will run
articles\set-up-hybrid-cluster-microsoft-hpc-pack-2012-sp1.md:	You will see two worker role instances are running in the service. HPC Pack also automatically deploys two **HpcProxy** instances (size Medium) to handle communication between the head node and Azure.
articles\storage-dotnet-how-to-use-blobs-17.md:    web role or worker role and click **Properties**.  
articles\storage-dotnet-how-to-use-blobs-20.md:    web role or worker role and click **Properties**.  
articles\storage-dotnet-how-to-use-queues-17.md:1.  Within the Solution Explorer of Visual Studio, in the **Roles** folder of your Azure Deployment Project, right-click your web role or worker role and click **Properties**.  
articles\storage-dotnet-how-to-use-queues-20.md:1.  Within the Solution Explorer of Visual Studio, in the **Roles** folder of your Azure Deployment Project, right-click your web role or worker role and click **Properties**.  
articles\storage-dotnet-how-to-use-table-storage-17.md:    web role or worker role and click **Properties**.  
articles\storage-dotnet-how-to-use-table-storage-20.md:    web role or worker role and click **Properties**.  
articles\storage-nodejs-how-to-use-queues.md:-   Passing messages from an Azure web role to a worker role
articles\storage-php-how-to-use-blobs.md:In this guide, you will use service features which can be called within a PHP application locally, or in code running within an Azure web role, worker role, or web site.
articles\storage-php-how-to-use-queues.md:In this guide, you will use Queue service features which can be called within a PHP application locally, or in code running within an Azure web role, worker role, or web site.
articles\storage-php-how-to-use-table-storage.md:In this guide, you will use Table service features which can be called from within a PHP application locally, or in code running within an Azure web role, worker role, or web site.
articles\store-new-relic-cloud-services-dotnet-application-performance-management.md:New Relic integrates seamlessly with Azure Web Roles and Worker roles.
articles\store-new-relic-web-sites-dotnet-application-performance-management.md:New Relic integrates seamlessly with Azure Web Roles, Worker roles and Web Sites.
articles\web-sites-available-operating-system-functionality.md:At its core, Azure Web Sites is a service running on top of the Azure PaaS (platform as a service) infrastructure. As a result, the local drives that are "attached" to a virtual machine are the same drive types available to any worker role running in Azure. This includes an operating system drive (the D:\ drive), an application drive that contains Azure Package cspkg files used exclusively by Azure Web Sites (and inaccessible to customers), and a "user" drive (the C:\ drive), whose size varies depending on the size of the VM.
articles\web-sites-available-operating-system-functionality.md:Each web site in Azure Web Sites runs as a random unique low-privileged worker process identity called the "application pool identity", described further here: [http://www.iis.net/learn/manage/configuring-security/application-pool-identities](http://www.iis.net/learn/manage/configuring-security/application-pool-identities). Application code uses this identity for basic read-only access to the operating system drive (the D:\ drive). This means application code can list common directory structures and read common files on operating system drive. Although this might appear to be a somewhat broad level of access, the same directories and files are accessible when you provision a worker role in an Azure hosted service and read the drive contents. 
articles\web-sites-nodejs-chat-app-socketio.md:> [WACOM.NOTE] For simplicity, this sample is limited to chatting between users connected to the same instance. This means that if the cloud service creates two worker role instances, users will only be able to chat with others connected to the same worker role instance. To scale the application to work with multiple role instances, you could use a technology like Service Bus to share the Socket.IO store state across instances. For examples, see the Service Bus Queues and Topics usage samples in the <a href="https://github.com/WindowsAzure/azure-sdk-for-node">Azure SDK for Node.js GitHub repository</a>.
includes\application-model.md:Deploying a role as a worker role (using the WorkerRole element) means
includes\application-model.md:You can certainly create and deploy a worker role that uses some other
includes\howto-queue-storage.md:    Worker role
includes\howto-service-bus-queues.md:-   Communication between web and worker roles in a multi-tier Windows
includes\intro-to-azure.md:But these VMs are distinct from the ones you create with Azure Virtual Machines. For one thing, Azure itself manages them, doing things like installing operating system patches and automatically rolling out new patched images. (This implies that your application shouldn't maintain state in web or worker role instances; it should instead be kept in one of the Azure data management options described in the next section.) Azure also monitors the VMs, restarting any that fail. 
includes\intro-to-azure.md:You have two roles to choose from when you create an instance, both based on Windows Server. The main difference between the two is that an instance of a web role runs IIS, while an instance of a worker role does not. Both are managed in the same way, however, and it's common for an application to use both. For example, a web role instance might accept requests from users, then pass them to a worker role instance for processing. To scale your application up or down, you can request that Azure create more instances of either role or shut down existing instances. And similar to Azure Virtual Machines, you're charged only for the time that each web or worker role instance is running. 
includes\intro-to-azure.md:Mobile Services allows you to do simple provisioning and management of data stored in a SQL Database, authenticate users through well-known identity providers like Facebook, Twitter, Microsoft or Google account, and use notification services to deliver push notifications to your app. With server-side code you can easily use additional data storage options like blob storage or MongoDB, consume Add-Ons from the Azure Store like SendGrid or Pusher, use other Azure Services like Service Bus and worker roles, or even connect to on-premises systems.  A service can be scaled as an app becomes more popular, and monitoring and logging are supported.
includes\intro-to-azure.md:One common use of Queues today is to let a web role instance communicate with a worker role instance within the same Cloud Services application. For example, suppose you create an Azure application for video sharing. The application consists of PHP code running in a web role that lets users upload and watch videos, together with a worker role implemented in C# that translates uploaded video into various formats. When a web role instance gets a new video from a user, it can store the video in a blob, then send a message to a worker role via a queue telling it where to find this new video. A worker role instance-it doesn't matter which one-will then read the message from the queue and carry out the required video translations in the background. Structuring an application in this way allows asynchronous processing, and it also makes the application easier to scale, since the number of web role instances and worker role instances can be varied independently.
includes\load-balancing-vms.md:For a cloud service that contains instances of web roles or worker roles, you can define a public endpoint in the service definition. For a cloud service that contains virtual machines, you can add an endpoint to a virtual machine when you create it or you can add the endpoint later. 
includes\tshootguide.md:of IISNode from [GitHub](https://github.com/windowsazure/iisnode/downloads) on your web role, worker role, or VM instance. As
