<properties linkid="dev-net-2-how-to-shared-access-signature-blobs" urlDisplayName="Shared Access Signatures Blob Service" pageTitle="Create and Use a Shared Access Signature with the Blob Service" metaKeywords="Get started Azure blob   Azure unstructured data   Azure unstructured storage   Azure blob   Azure blob storage   Azure blob .NET   Azure blob C#   Azure blob C#  shared access signature" metaDescription="Create shared access signatures to delegate access to storage account resources, and consume them from a separate client application. Samples are written in C#." metaCanonical="" disqusComments="1" umbracoNaviHide="1" />

<div chunk="../chunks/article-left-menu.md" />

# Create and Use a Shared Access Signature with the Windows Azure Blob Service

This tutorial shows you how to generate and then use shared access signatures (SAS) with the Windows Azure Blob service. The examples are written in C# and use the Windows Azure Storage Client Library for .NET (Version 2.0). The scenarios covered include these aspects of working with shared access signatures:

- Generating a shared access signature on a container
- Generating a shared access signature on a blob
- Creating a stored access policy to manage signatures on a container’s resources
- Testing the shared access signatures from a client application

# Overview of Shared Access Signatures #
A shared access signature provides delegated access to resources in your storage account. This means that you can grant access to blobs, queues, or tables for a specified period of time and with a specified set of permissions, without having to share your account access key. The shared access signature is a URI that encompasses in its query parameters all of the information necessary for authenticated access to a storage resource. To access storage resources with the shared access signature, the client only needs to pass in the signature to the appropriate constructor or method; passing in additional credentials is not required.

## When to Use a Shared Access Signature ##
You can use a shared access signature when you want to provide limited access to resources in your storage account to an entity that can’t be trusted with the account key. That entity might be a client application, such as a mobile application, or a web service, or a web application. For example, users of a video sharing service may need to be able to upload a video from the client application. Design-wise, it makes sense for the video files to be stored in a single storage account, but giving every client the access key for that account would compromise its security. Instead, the client application can use a shared access signature generated by the service to grant write access to the storage account. Users of the client application can upload new videos to be stored as blobs via the shared access signature.

Another scenario in which a shared access signature is useful is in limiting the amount of traffic that a front-end service needs to handle between a client and a storage account. Using the example of a video-sharing service again, suppose that users upload their videos to a web service, which then writes potentially large binary files to the storage account as blobs. The web service has to handle a significant amount of traffic; its performance may be diminished and it may be difficult to scale. If the role of the web application is instead to authenticate users and return a shared access signature to the client application, the video can be written directly to the Blob service, circumventing the front-end web service and reducing the amount of traffic it needs to handle.

Here is a diagram that compares two designs for an application that writes video files to the Blob service. In the first design, where no shared access signature is used, a web service receives file data from a client application, processes it, and writes out the blob. In the second design, the web service does not handle file data, but instead returns a shared access signature with write permissions to the client, and the client uses the shared access signature to write the file directly to the Blob service.

![sas-diagram][]

## How a Shared Access Signature Works ##

A shared access signature is a URI that points to a storage resource and includes a special set of query parameters that indicate how the resource may be accessed by the client that is being granted access to the resource.

A shared access signature has the following constraints that define it:

- The resource itself. Storage resources for which you can delegate access include containers, blobs, queues, tables, and ranges of table entities.
- Start time. This is the time at which the SAS becomes valid. The start time for a shared access signature is optional; if omitted, the SAS is effective immediately.
- Expiry time. This is the time after which the SAS is no longer valid. Best practices recommend that you either specify an expiry time for a SAS, or associate it with a stored access policy (see more below).
- Permissions. The permissions specified on the SAS indicate what operations the client can perform against the storage resource using the SAS. 
 
Here is an example of a SAS URI that provides read and write permissions to a blob. The table breaks down each part of the URI to help you understand how it contributes to the SAS:

https://myaccount.blob.core.windows.net/sascontainer/sasblob.txt?sv=2012-02-12&st=2013-04-29T22%3A18%3A26Z&se=2013-04-30T02%3A23%3A26Z&sr=b&sp=rw&sig=Z%2FRHIX5Xcg0Mq2rqI3OlWTjEg2tYkboXr1P9ZUXDtkk%3D

<table border="1" cellpadding="0" cellspacing="0">
    <tbody>
        <tr>
            <td valign="top" width="213">
                <p>
                    Blob URI
                </p>
            </td>
            <td valign="top" width="213">
                <p>
                    https://myaccount.blob.core.windows.net/sascontainer/sasblob.txt
                </p>
            </td>
            <td valign="top" width="213">
                <p>
                    The address of the blob. Note that using HTTPS is highly recommended.
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="213">
                <p>
                    Storage services version
                </p>
            </td>
            <td valign="top" width="213">
                <p>
                    sv=2012-02-12
                </p>
            </td>
            <td valign="top" width="213">
                <p>
                    For storage services version 2012-02-12 and later, this parameter indicates the version to use.
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="213">
                <p>
                    Start time
                </p>
            </td>
            <td valign="top" width="213">
                <p>
                    st=2013-04-29T22%3A18%3A26Z
                </p>
            </td>
            <td valign="top" width="213">
                <p>
                    Specified in an ISO 8061 format.
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="213">
                <p>
                    Expiry time
                </p>
            </td>
            <td valign="top" width="213">
                <p>
                    se=2013-04-30T02%3A23%3A26Z
                </p>
            </td>
            <td valign="top" width="213">
                <p>
                    Specified in an ISO 8061 format.
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="213">
                <p>
                    Resource
                </p>
            </td>
            <td valign="top" width="213">
                <p>
                    sr=b
                </p>
            </td>
            <td valign="top" width="213">
                <p>
                    The resource is a blob.
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="213">
                <p>
                    Permissions
                </p>
            </td>
            <td valign="top" width="213">
                <p>
                    sp=rw
                </p>
            </td>
            <td valign="top" width="213">
                <p>
                    The permissions granted by the SAS include Read (r) and Write (w).
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="213">
                <p>
                    Signature
                </p>
            </td>
            <td valign="top" width="213">
                <p>
                    sig=Z%2FRHIX5Xcg0Mq2rqI3OlWTjEg2tYkboXr1P9ZUXDtkk%3D
                </p>
            </td>
            <td valign="top" width="213">
                <p>
                    Used to authenticate access to the blob. The signature is an HMAC computed over a string-to-sign and key using the SHA256 algorithm, and
                    then encoded using Base64 encoding.
                </p>
            </td>
        </tr>
    </tbody>
</table>


## Shared Access Signature Permissions ##
The possible permissions for a shared access signature on each type of resource are outlined in the following table:

<table border="1" cellpadding="0" cellspacing="0" width="100%">
    <tbody>
        <tr>
            <td valign="top" width="33%">
                <p>
                    <strong>Storage Resource</strong>
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    <strong>Permission</strong>
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    <strong>Allowed Operations</strong>
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="33%">
                <p>
                    Container
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    Read
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    Read the content, properties, metadata or block list of any blob in the container. Use any blob in the container as the source of a copy
                    operation.
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="33%">
                <p>
                    Container
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    Write
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    For any blob in the container, create or write content, properties, metadata, or block list. Snapshot or lease the blob. Resize the blob
                    (page blob only).
                </p>
                <p>
                    Note that you cannot grant permissions to read or write container properties or metadata.
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="33%">
                <p>
                    Container
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    Delete
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    Delete any blob in the container.
                </p>
                <p>
                    Note that you cannot grant permissions to delete a container.
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="33%">
                <p>
                    Container
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    List
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    List blobs in the container.
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="33%">
                <p>
                    Blob
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    Read
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    Read the content, properties, metadata and block list. Use the blob as the source of a copy operation.
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="33%">
                <p>
                    Blob
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    Write
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    Create or write content, properties, metadata, or block list. Snapshot or lease the blob. Resize the blob (page blob only).
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="33%">
                <p>
                    Blob
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    Delete
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    Delete the blob.
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="33%">
                <p>
                    Queue
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    Read
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    Read metadata and properties, including message count. Peek at messages.
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="33%">
                <p>
                    Queue
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    Add
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    Add messages to the queue.
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="33%">
                <p>
                    Queue
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    Update
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    Update messages in the queue.
                </p>
                <p>
                    Note that you should use the Process permission with the Update permission so you can first get the message you want to update.
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="33%">
                <p>
                    Queue
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    Process
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    Get and delete messages from the queue.
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="33%">
                <p>
                    Table or range of entities
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    Read/Query
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    Get entities and query entities.
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="33%">
                <p>
                    Table or range of entities
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    Add
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    Add entities.
                </p>
                <p>
                    Note that Add and Update permissions are required for upsert operations.
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="33%">
                <p>
                    Table or range of entities
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    Update
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    Update entities.
                </p>
                <p>
                    Note that Add and Update permissions are required for upsert operations.
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top" width="33%">
                <p>
                    Table or range of entities
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    Delete
                </p>
            </td>
            <td valign="top" width="33%">
                <p>
                    Delete entities.
                </p>
            </td>
        </tr>
    </tbody>
</table>

## Managing Shared Access Signatures with a Stored Access Policy ##
A stored access policy adds an additional level of sophistication to working with shared access signatures. A stored access policy can be defined on a container, a queue, or a table, and then used to control one or more signatures defined for the container or its blobs, the queue, or the table. For reasons we’ll discuss in more detail below, best practices recommend using stored access policies to manage shared access signatures.

With a stored access policy, you can specify permissions, start time, and expiry time for shared access signatures as part of the policy, rather than on the shared access signature itself. When you create a shared access signature, you can associate it with a specific stored access policy, and it then inherits the constraints specified by the policy. The policy can be changed without reissuing the shared access signature, by changing those constraints. You can extend the lifetime of a shared access signature in this way, and you can also revoke it instantly by deleting the stored access policy that it’s associated with. This power to revoke the shared access signature is an important reason to use a stored access policy.

A container can have up to five shared access policies, and each policy can be associated with an unlimited number of shared access signatures. For more details on shared access policies, see [Use a Stored Access Policy](http://msdn.microsoft.com/en-us/library/ee393341.aspx "Use a Stored Access Policy").

## A Note on Security ##

Shared access signature URIs are keys that grant permissions to storage resources, and should be protected in the same manner as a shared key. Follow these best practices to protect your shared access signatures:

- Ensure that operations that use a shared access signature against resources in your storage account are performed only over an HTTPS connection. A shared access signature used over HTTP is vulnerable to replay attacks and leaks.
- When you distribute a shared access signature URI, you should always do so over a secure connection such as HTTPS. A shared access signature sent over an HTTP connection can be intercepted and used maliciously. 
- Use a stored access policy to manage shared access signatures, so that you can change or revoke the signature after it has been distributed. Should it be necessary to revoke a shared access signature, you can delete the stored access policy. When you delete the policy, every signature that is associated with it is revoked.
- Always specify an expiry time for an ad-hoc shared access signature (that, is, one that is not associated with a stored access policy) so that it is not valid indefinitely. 
- If you fear that the security of your storage account has been compromised in a serious way, you can rotate all of your storage account keys to ensure that all shared access signatures in circulation for the storage account are revoked. This is the only way to revoke a shared access signature that is not associated with a stored access policy and that has no expiry time.

# About this Tutorial #
In this tutorial, we’ll focus on creating shared access signatures for containers and blobs by creating two console applications. The first console application generates shared access signatures on a container and on a blob. This application has knowledge of the storage account keys. The second console application, which will act as a client application, accesses container and blob resources using the shared access signatures created with the first application. This application uses the shared access signatures only to authenticate its access to the container and blob resources – it does not have knowledge of the account keys.

# Part 1: Create a Console Application to Generate Shared Access Signatures #

First, ensure that you have the Windows Azure Storage Client Library for .NET (Version 2.0) installed. You can install the [NuGet package](http://nuget.org/packages/WindowsAzure.Storage/ "NuGet package") containing the most up-to-date assemblies for the client library; this is the recommended method for ensuring that you have the most recent fixes. You can also download the client library as part of the most recent version of the [Windows Azure SDK for .NET](http://www.windowsazure.com/en-us/downloads/).

In Visual Studio, create a new Windows console application and name it **GenerateSharedAccessSignatures**. Add references to  **Microsoft.WindowsAzure.Configuration.dll** and **Microsoft.WindowsAzure.Storage.dll**, using either of the following approaches:

- 	If you want to install the NuGet package, first install the [NuGet Package Manager Extension for Visual Studio](http://visualstudiogallery.msdn.microsoft.com/27077b70-9dad-4c64-adcf-c7cf6bc9970c). In Visual Studio, select **Project | Manage NuGet Packages**, search online for **Windows Azure Storage**, and follow the instructions to install.
- 	Alternatively, locate the assemblies in your installation of the Windows Azure SDK and add references to them.
 
At the top of the Program.cs file, add the following **using** statements:

    using System.IO;    
    using Microsoft.WindowsAzure;
    using Microsoft.WindowsAzure.Storage;
    using Microsoft.WindowsAzure.Storage.Blob;

Edit the app.config file so that it contains a configuration setting with a connection string that points to your storage account. Your app.config file should look similar to this one:

    <configuration>
      <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />
      </startup>
      <appSettings>
        <add key="StorageConnectionString" value="DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=mykey"/>
      </appSettings> 
    </configuration>

## Generate a Shared Access Signature URI for a Container ##

To begin with, we’ll add a method to generate a shared access signature on a new container. In this case the signature is not associated with a stored access policy, so it carries on the URI the information indicating its expiry time and the permissions that it grants.

First, add code to the **Main()** method to authenticate access to your storage account and create a new container:

    static void Main(string[] args)
    {
	    //Parse the connection string and return a reference to the storage account.
	    CloudStorageAccount storageAccount = CloudStorageAccount.Parse(CloudConfigurationManager.GetSetting("StorageConnectionString"));
	    
	    //Create the blob client object.
	    CloudBlobClient blobClient = storageAccount.CreateCloudBlobClient();
	    
	    //Get a reference to a container to use for the sample code, and create it if it does not exist.
	    CloudBlobContainer container = blobClient.GetContainerReference("sascontainer");
	    container.CreateIfNotExists();
	    
	    //Insert calls to the methods created below here…
	    
	    //Require user input before closing the console window.
	    Console.ReadLine();
    }

Next, add a new method that generates the shared access signature for the container and returns the signature URI:

    static string GetContainerSasUri(CloudBlobContainer container)
    {
	    //Set the expiry time and permissions for the container.
	    //In this case no start time is specified, so the shared access signature becomes valid immediately.
	    SharedAccessBlobPolicy sasConstraints = new SharedAccessBlobPolicy();
	    sasConstraints.SharedAccessExpiryTime = DateTime.UtcNow.AddHours(4);
	    sasConstraints.Permissions = SharedAccessBlobPermissions.Write | SharedAccessBlobPermissions.List;
	    
	    //Generate the shared access signature on the container, setting the constraints directly on the signature.
	    string sasContainerToken = container.GetSharedAccessSignature(sasConstraints);
	    
	    //Return the URI string for the container, including the SAS token.
	    return container.Uri + sasContainerToken;
    }

Add the following lines at the bottom of the **Main()** method, before the call to **Console.ReadLine()**, to call **GetContainerSasUri()** and write the signature URI to the console window:

    //Generate a SAS URI for the container, without a stored access policy.
    Console.WriteLine("Container SAS URI: " + GetContainerSasUri(container));
    Console.WriteLine();

Compile and run to output the shared access signature URI for the new container. The URI will be similar to the following URI:       

https://storageaccount.blob.core.windows.net/sascontainer?sv=2012-02-12&se=2013-04-13T00%3A12%3A08Z&sr=c&sp=wl&sig=t%2BbzU9%2B7ry4okULN9S0wst%2F8MCUhTjrHyV9rDNLSe8g%3D

Once you have run the code, the shared access signature that you created on the container will be valid for the next four hours. The signature grants a client permission to list blobs in the container and to write a new blob to the container.

## Generate a Shared Access Signature URI for a Blob ##

Next, we’ll write similar code to create a new blob within the container and generate a shared access signature for it. This shared access signature is not associated with a stored access policy, so it includes the start time, expiry time, and permission information on the URI.

Add a new method that creates a new blob and write some text to it, then generates a shared access signature and returns the signature URI:

    static string GetBlobSasUri(CloudBlobContainer container)
    {
	    //Get a reference to a blob within the container.
	    CloudBlockBlob blob = container.GetBlockBlobReference("sasblob.txt");
	    
	    //Upload text to the blob. If the blob does not yet exist, it will be created. 
	    //If the blob does exist, its existing content will be overwritten.
	    string blobContent = "This blob will be accessible to clients via a Shared Access Signature.";
	    MemoryStream ms = new MemoryStream(Encoding.UTF8.GetBytes(blobContent));
	    ms.Position = 0;
	    using (ms)
	    {
		    blob.UploadFromStream(ms);
	    }
	    
	    //Set the expiry time and permissions for the blob.
	    //In this case the start time is specified as a few minutes in the past, to mitigate clock skew.
	    //The shared access signature will be valid immediately.
	    SharedAccessBlobPolicy sasConstraints = new SharedAccessBlobPolicy();
	    sasConstraints.SharedAccessStartTime = DateTime.UtcNow.AddMinutes(-5);
	    sasConstraints.SharedAccessExpiryTime = DateTime.UtcNow.AddHours(4);
	    sasConstraints.Permissions = SharedAccessBlobPermissions.Read | SharedAccessBlobPermissions.Write;
	    
	    //Generate the shared access signature on the blob, setting the constraints directly on the signature.
	    string sasBlobToken = blob.GetSharedAccessSignature(sasConstraints);
	    
	    //Return the URI string for the container, including the SAS token.
	    return blob.Uri + sasBlobToken;
    }

At the bottom of the **Main()** method, add the following lines to call **GetBlobSasUri()**, before the call to **Console.ReadLine()**, and write the shared access signature URI to the console window:    
    
    //Generate a SAS URI for a blob within the container, without a stored access policy.
    Console.WriteLine("Blob SAS URI: " + GetBlobSasUri(container));
    Console.WriteLine();
    

Compile and run to output the shared access signature URI for the new blob. The URI will be similar to the following URI:

https://storageaccount.blob.core.windows.net/sascontainer/sasblob.txt?sv=2012-02-12&st=2013-04-12T23%3A37%3A08Z&se=2013-04-13T00%3A12%3A08Z&sr=b&sp=rw&sig=dF2064yHtc8RusQLvkQFPItYdeOz3zR8zHsDMBi4S30%3D

## Create a Stored Access Policy on the Container ##

Now let’s create a stored access policy on the container, which will define the constraints for any shared access signatures that are associated with it.

In the previous examples, we specified the start time (implicitly or explicitly), the expiry time, and the permissions on the shared access signature URI itself. In the following examples, we will specify these on the stored access policy and not on the shared access signature. Doing so enables us to change these constraints without reissuing the shared access signature.

Note that it’s possible to one or more of the constraints on the shared access signature and the remainder on the stored access policy. However, you can only specify the start time, expiry time, and permissions in one place or the other; for example, you can’t specify permissions on the shared access signature and also specify them on the stored access policy.

Add a new method that creates a new stored access policy and returns the name of the policy:

    static void CreateSharedAccessPolicy(CloudBlobClient blobClient, CloudBlobContainer container, string policyName)
    {
	    //Create a new stored access policy and define its constraints.
	    SharedAccessBlobPolicy sharedPolicy = new SharedAccessBlobPolicy()
	    {
		    SharedAccessExpiryTime = DateTime.UtcNow.AddHours(10),
		    Permissions = SharedAccessBlobPermissions.Read | SharedAccessBlobPermissions.Write | SharedAccessBlobPermissions.List
	    };
	    
	    //Get the container's existing permissions.
	    BlobContainerPermissions permissions = new BlobContainerPermissions();
	    
	    //Add the new policy to the container's permissions.
	    permissions.SharedAccessPolicies.Clear();
	    permissions.SharedAccessPolicies.Add(policyName, sharedPolicy);
	    container.SetPermissions(permissions);
    }

At the bottom of the **Main()** method, before the call to **Console.ReadLine()**, add the following lines to call the **CreateSharedAccessPolicy()** method:    

    //Create an access policy on the container, which may be optionally used to provide constraints for 
    //shared access signatures on the container and the blob.
    string sharedAccessPolicyName = "tutorialpolicy";
    CreateSharedAccessPolicy(blobClient, container, sharedAccessPolicyName);

## Generate a Shared Access Signature URI on the Container That Uses an Access Policy ##

Next, we’ll create another shared access signature on the container that we created earlier, but this time we’ll associate the signature with the access policy that we created in the previous example.

Add a new method to generate another shared access signature on the container:

    static string GetContainerSasUriWithPolicy(CloudBlobContainer container, string policyName)
    {
	    //Generate the shared access signature on the container. In this case, all of the constraints for the 
	    //shared access signature are specified on the stored access policy.
	    string sasContainerToken = container.GetSharedAccessSignature(null, policyName);
	    
	    //Return the URI string for the container, including the SAS token.
	    return container.Uri + sasContainerToken;
    }
    
At the bottom of the **Main()** method, before the call to **Console.ReadLine()**, add the following lines to call the **GetContainerSasUriWithPolicy** method:

    //Generate a SAS URI for the container, using a stored access policy to set constraints on the SAS.
    Console.WriteLine("Container SAS URI using stored access policy: " + GetContainerSasUriWithPolicy(container, sharedAccessPolicyName));
    Console.WriteLine();

## Generate a Shared Access Signature URI on the Blob That Uses an Access Policy ##

Finally, we’ll add a similar method to create another blob and generate a shared access signature that’s associated with an access policy.

Add a new method to create a blob and generate a shared access signature:

    static string GetBlobSasUriWithPolicy(CloudBlobContainer container, string policyName)
    {
	    //Get a reference to a blob within the container.
	    CloudBlockBlob blob = container.GetBlockBlobReference("sasblobpolicy.txt");
	    
	    //Upload text to the blob. If the blob does not yet exist, it will be created. 
	    //If the blob does exist, its existing content will be overwritten.
	    string blobContent = "This blob will be accessible to clients via a shared access signature. " + 
	    "A stored access policy defines the constraints for the signature.";
	    MemoryStream ms = new MemoryStream(Encoding.UTF8.GetBytes(blobContent));
	    ms.Position = 0;
	    using (ms)
	    {
		    blob.UploadFromStream(ms);
	    }
	    
	    //Generate the shared access signature on the blob.
	    string sasBlobToken = blob.GetSharedAccessSignature(null, policyName);
	    
	    //Return the URI string for the container, including the SAS token.
	    return blob.Uri + sasBlobToken;
    }

At the bottom of the **Main()** method, before the call to **Console.ReadLine()**, add the following lines to call the **GetBlobSasUriWithPolicy** method:    

    //Generate a SAS URI for a blob within the container, using a stored access policy to set constraints on the SAS.
    Console.WriteLine("Blob SAS URI using stored access policy: " + GetBlobSasUriWithPolicy(container, sharedAccessPolicyName));
    Console.WriteLine();

The **Main()** method should now look like this in its entirety. Run it to write the shared access signature URIs to the console window, then copy and paste them into a text file for use in the second part of this tutorial.    

    static void Main(string[] args)
    {
	    //Parse the connection string and return a reference to the storage account.
	    CloudStorageAccount storageAccount = CloudStorageAccount.Parse(CloudConfigurationManager.GetSetting("StorageConnectionString"));
	    
	    //Create the blob client object.
	    CloudBlobClient blobClient = storageAccount.CreateCloudBlobClient();
	    
	    //Get a reference to a container to use for the sample code, and create it if it does not exist.
	    CloudBlobContainer container = blobClient.GetContainerReference("sascontainer");
	    container.CreateIfNotExists();
	    
	    //Generate a SAS URI for the container, without a stored access policy.
	    Console.WriteLine("Container SAS URI: " + GetContainerSasUri(container));
	    Console.WriteLine();
	    
	    //Generate a SAS URI for a blob within the container, without a stored access policy.
	    Console.WriteLine("Blob SAS URI: " + GetBlobSasUri(container));
	    Console.WriteLine();
	    
	    //Create an access policy on the container, which may be optionally used to provide constraints for 
	    //shared access signatures on the container and the blob.
	    string sharedAccessPolicyName = "tutorialpolicy";
	    CreateSharedAccessPolicy(blobClient, container, sharedAccessPolicyName);
	    
	    //Generate a SAS URI for the container, using a stored access policy to set constraints on the SAS.
	    Console.WriteLine("Container SAS URI using stored access policy: " + GetContainerSasUriWithPolicy(container, sharedAccessPolicyName));
	    Console.WriteLine();
	    
	    //Generate a SAS URI for a blob within the container, using a stored access policy to set constraints on the SAS.
	    Console.WriteLine("Blob SAS URI using stored access policy: " + GetBlobSasUriWithPolicy(container, sharedAccessPolicyName));
	    Console.WriteLine();
	    
	    Console.ReadLine();
    }

When you run the GenerateSharedAccessSignatures console application, you'll see output similar to the following in the console window. These are the shared access signatures that you'll use in Part 2 of the tutorial.

![sas-console-output-1][]

# Part 2: Create a Console Application to Test the Shared Access Signatures #

To test the shared access signatures created in the previous examples, we’ll create a second console application that uses the signatures to perform operations on the container and on a blob.

Note that if more than four hours have passed since you completed the first part of the tutorial, the signatures you generated where the expiry time was set to four hours will no longer be valid. Similarly, the signatures associated with the stored access policy expire after 10 hours. If one or both of these intervals have passed, you should run the code in the first console application to generate fresh shared access signatures for use in the second part of the tutorial.

In Visual Studio, create a new Windows console application and name it **ConsumeSharedAccessSignatures**. Add references to **Microsoft.WindowsAzure.Configuration.dll** and **Microsoft.WindowsAzure.Storage.dll**, as you did previously.

At the top of the Program.cs file, add the following **using** statements:

    using System.IO;
    using Microsoft.WindowsAzure.Storage;
    using Microsoft.WindowsAzure.Storage.Blob;
    
In the body of the **Main()** method, add the following constants, and update their values to the shared access signatures that you generated in part 1 of the tutorial.

    static void Main(string[] args)
    {
	    string containerSAS = "<your container SAS>";
	    string blobSAS = "<your blob SAS>";
	    string containerSASWithAccessPolicy = "<your container SAS with access policy>";
	    string blobSASWithAccessPolicy = "<your blob SAS with access policy>";
    }
    
## Add a Method to Try Container Operations Using a Shared Access Signature ##

Next, we’ll add a method that tests some representative container operations using a shared access signature on the container. Note that the shared access signature is used to return a reference to the container, authenticating access to the container based on the signature alone.

Add the following method to Program.cs:

<pre>
static void UseContainerSAS(string sas)
{
    //Try performing container operations with the SAS provided.

    //Return a reference to the container using the SAS URI.
    CloudBlobContainer container = new CloudBlobContainer(new Uri(sas));

    //Create a list to store blob URIs returned by a listing operation on the container.
    List<Uri> blobUris = new List<Uri>();

    try
    {
        //Write operation: write a new blob to the container. 
        CloudBlockBlob blob = container.GetBlockBlobReference("blobCreatedViaSAS.txt");
        string blobContent = "This blob was created with a shared access signature granting write permissions to the container. ";
        MemoryStream msWrite = new MemoryStream(Encoding.UTF8.GetBytes(blobContent));
        msWrite.Position = 0;
        using (msWrite)
        {
            blob.UploadFromStream(msWrite);
        }
        Console.WriteLine("Write operation succeeded for SAS " + sas);
        Console.WriteLine();
    }
    catch (StorageException e)
    {
        Console.WriteLine("Write operation failed for SAS " + sas);
        Console.WriteLine("Additional error information: " + e.Message);
        Console.WriteLine();
    }

    try
    {
        //List operation: List the blobs in the container, including the one just added.
        foreach (ICloudBlob blobListing in container.ListBlobs())
        {
            blobUris.Add(blobListing.Uri);
        }
        Console.WriteLine("List operation succeeded for SAS " + sas);
        Console.WriteLine();
    }
    catch (StorageException e)
    {
        Console.WriteLine("List operation failed for SAS " + sas);
        Console.WriteLine("Additional error information: " + e.Message);
        Console.WriteLine();
    }

    try
    {
        //Read operation: Get a reference to one of the blobs in the container and read it. 
        CloudBlockBlob blob = container.GetBlockBlobReference(blobUris[0].ToString());
        MemoryStream msRead = new MemoryStream();
        msRead.Position = 0;
        using (msRead)
        {
            blob.DownloadToStream(msRead);
            Console.WriteLine(msRead.Length);
        }
        Console.WriteLine("Read operation succeeded for SAS " + sas);
        Console.WriteLine();
    }
    catch (StorageException e)
    {
        Console.WriteLine("Read operation failed for SAS " + sas);
        Console.WriteLine("Additional error information: " + e.Message);
        Console.WriteLine();
    }
    Console.WriteLine();

    try
    {
        //Delete operation: Delete a blob in the container.
        CloudBlockBlob blob = container.GetBlockBlobReference(blobUris[0].ToString());
        blob.Delete();
        Console.WriteLine("Delete operation succeeded for SAS " + sas);
        Console.WriteLine();
    }
    catch (StorageException e)
    {
        Console.WriteLine("Delete operation failed for SAS " + sas);
        Console.WriteLine("Additional error information: " + e.Message);
        Console.WriteLine();
    }        
}
</pre>

Update the **Main()** method to call **UseContainerSAS()** with both of the shared access signatures that you created on the container:

<pre>
static void Main(string[] args)
{
    string containerSAS = "<your container SAS>";
    string blobSAS = "<your blob SAS>";
    string containerSASWithAccessPolicy = "<your container SAS with access policy>";
    string blobSASWithAccessPolicy = "<your blob SAS with access policy>";

    //Call the test methods with the shared access signatures created on the container, with and without the access policy.
    UseContainerSAS(containerSAS);
    UseContainerSAS(containerSASWithAccessPolicy); 
    
    //Call the test methods with the shared access signatures created on the blob, with and without the access policy.
    UseBlobSAS(blobSAS);
    UseBlobSAS(blobSASWithAccessPolicy);

    Console.ReadLine();
}
</pre>

## Add a Method to Try Blob Operations Using a Shared Access Signature ##

Finally, we’ll add a method that tests some representative blob operations using a shared access signature on the blob. In this case we use the constructor **CloudBlockBlob(String)**, passing in the shared access signature, to return a reference to the blob. No other authentication is required; it’s based on the signature alone.

Add the following method to Program.cs:

<pre>
static void UseBlobSAS(string sas)
{
    //Try performing blob operations using the SAS provided.

    //Return a reference to the blob using the SAS URI.
    CloudBlockBlob blob = new CloudBlockBlob(new Uri(sas));

    try
    {
        //Write operation: write a new blob to the container. 
        string blobContent = "This blob was created with a shared access signature granting write permissions to the blob. ";
        MemoryStream msWrite = new MemoryStream(Encoding.UTF8.GetBytes(blobContent));
        msWrite.Position = 0;
        using (msWrite)
        {
            blob.UploadFromStream(msWrite);
        }
        Console.WriteLine("Write operation succeeded for SAS " + sas);
        Console.WriteLine();
    }
    catch (StorageException e)
    {
        Console.WriteLine("Write operation failed for SAS " + sas);
        Console.WriteLine("Additional error information: " + e.Message);
        Console.WriteLine();
    }

    try
    {
        //Read operation: Read the contents of the blob.
        MemoryStream msRead = new MemoryStream();
        using (msRead)
        {
            blob.DownloadToStream(msRead);
            msRead.Position = 0;
            using (StreamReader reader = new StreamReader(msRead, true))
            {
                string line;
                while ((line = reader.ReadLine()) != null)
                {
                    Console.WriteLine(line);
                }
            }
        }
        Console.WriteLine("Read operation succeeded for SAS " + sas);
        Console.WriteLine();
    }
    catch (StorageException e)
    {
        Console.WriteLine("Read operation failed for SAS " + sas);
        Console.WriteLine("Additional error information: " + e.Message);
        Console.WriteLine();
    }

    try
    {
        //Delete operation: Delete the blob.
        blob.Delete();
        Console.WriteLine("Delete operation succeeded for SAS " + sas);
        Console.WriteLine();
    }
    catch (StorageException e)
    {
        Console.WriteLine("Delete operation failed for SAS " + sas);
        Console.WriteLine("Additional error information: " + e.Message);
        Console.WriteLine();
    }        
}
</pre>

Update the **Main()** method to call **UseBlobSAS()** with both of the shared access signatures that you created on the blob:

<pre>
static void Main(string[] args)
{
    string containerSAS = "<your container SAS>";
    string blobSAS = "<your blob SAS>";
    string containerSASWithAccessPolicy = "<your container SAS with access policy>";
    string blobSASWithAccessPolicy = "<your blob SAS with access policy>";

    //Call the test methods with the shared access signatures created on the container, with and without the access policy.
    UseContainerSAS(containerSAS);
    UseContainerSAS(containerSASWithAccessPolicy); 
    
    //Call the test methods with the shared access signatures created on the blob, with and without the access policy.
    UseBlobSAS(blobSAS);
    UseBlobSAS(blobSASWithAccessPolicy);

    Console.ReadLine();
}
</pre>

Run the console application and observe the output to see which operations are permitted for which signatures. The output in the console window will look similar to the following:

![sas-console-output-2][]

# Next Steps #

[Manage Access to Containers, Blobs, Tables, and Queues](http://msdn.microsoft.com/en-us/library/ee393343.aspx "Manage Access to Containers, Blobs, Tables, and Queues")

[Introducing Table SAS (Shared Access Signature), Queue SAS and update to Blob SAS](http://blogs.msdn.com/b/windowsazurestorage/archive/2012/06/12/introducing-table-sas-shared-access-signature-queue-sas-and-update-to-blob-sas.aspx)