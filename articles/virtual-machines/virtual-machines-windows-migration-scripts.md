<properties
	pageTitle="Migrate a single VM From Azure Service Management to Azure Resource Manager using PowerShell"
	description="This article shows you how to migrate a single VM From Azure Service Management to Azure Resource Manager using PowerShell scripts"
	services="virtual-machines-windows"
	documentationCenter=""
	authors="singhkay"
	manager="drewm"
	editor=""
	tags="azure-resource-manager"/>

<tags
	ms.service="virtual-machines-windows"
	ms.workload="infrastructure-services"
	ms.tgt_pltfrm="vm-windows"
	ms.devlang="na"
	ms.topic="article"
	ms.date="04/27/2016"
	ms.author="singhkay"/>

# Migrate a single VM From Azure Service Management to Azure Resource Manager using PowerShell

This article will show you how to use the scripts located at [Azure/classic-iaas-resourcemanager-migration](https://github.com/Azure/classic-iaas-resourcemanager-migration) to migrate a **single** VM from Azure Service Management stack to the Azure Resource Manager stack.

> [Azure.NOTE] Migrating with these scripts will cause downtime for your Virtual Machine.

## Getting the scripts

You can either get the scripts by downloading the zip file from the above specified repo or clone the repo using the **either** of the commands below

```
git clone https://github.com/Azure/classic-iaas-resourcemanager-migration.git
```
**OR**
```
git clone git@github.com:Azure/classic-iaas-resourcemanager-migration.git
```

## Import the migration module

The next step is to import the module into your PowerShell session. This can be done with the below command

```
Import-Module .\asm2arm.psd1
```

## Authenticate with Azure Service Management and Azure Resource Manager subscriptions

Before you can migrate your VM, you need to authenticate your PowerShell session to both Azure Service Management and Azure Resource Manager stacks. This can be done with the following cmdlets

```
Add-AzureAccount
Login-AzureRmAccount
```

>[Azure.NOTE] Make sure default subscriptions are selected using `Select-AzureSubscription` for Azure Service Management and Set-AzureRmContext for Azure Resource Manager

## Using the scripts

### The cmdlets

Importing the module will add the below two cmdlets to your session.

```
Add-AzureSMVmToRM
New-AzureSmToRMDeployment
```

These cmdlets accomplish the below specified functionality.

#### Add-AzureSMVmToRM
- Generates a set of Azure Resource Manager templates and imperative PowerShell scripts (to copy the disk blobs and if the VM has VM Agent Extensions), given a Virtual Machine

>[Azure.NOTE] If the `-Deploy` switch is specified, this cmdlet calls the `New-AzureSmToRMDeployment` cmdlet to deploy the above generated Azure Resource Manager templates and imperative PowerShell Scripts.

#### New-AzureSmToRMDeployment
- Deploys the templates and imperative PowerShell scripts generated by the `Add-AzureSMVmToRM` cmdlet to start the migration. 

### Identify the Virtual Machine to migrate

This can be done by either storing the Virtual Machine state in a variable and passing that on to the `Add-AzureSMVmToRM` cmdlet or using the `ServiceName` and VM `Name` parmaeters directly. Once you identify the Virtual Machine, you can use the `Add-AzureSMVmToRM` cmdlet to migrate it.

```
$vm = Get-AzureVm -ServiceName acloudservice -Name atestvm
Add-AzureSMVmToRM -VM $vm -ResourceGroupName aresourcegroupname -DiskAction CopyDisks -OutputFileFolder D:\myarmtemplates -AppendTimeStampForFiles -Deploy
```

**OR**

```
Add-AzureSMVmToRM -ServiceName acloudservice -Name atestvm -ResourceGroupName aresourcegroupname -DiskAction CopyDisks -OutputFileFolder D:\myarmtemplates -AppendTimeStampForFiles -Deploy
```

>[Azure.NOTE] In the above examples since we are using the `-Deploy` switch, use of `New-AzureSmToRMDeployment` cmdlet is not needed.

## How does the migration work with these scripts?

The cmdlets go through steps for cloning the VM, and generate resources as custom PowerShell hash tables for Storage, Network and Compute resource providers.
Those hash tables representing the resources are appended to an array, later turned into a template by serializing to JSON, and written to a file.

The template creates files depending on the existence of VM agent extensions and DiskAction option value. Those are all placed in the directory specified by OutputFileFolder parameter. The files are:

1. `<ServiceName>-<VMName>-setup<optional timestamp>.json`: This file represents the resources that are needed to be prepared before the VM is cloned, and potentially be the same for any subsequent VMs (we do not maintain state between subsequent runs, but since a storage account needs to be provisioned before a blob copy operation happens, which is done imperatively, it was only logical to group like resources into one)

2.  `<ServiceName>-<VMName>-deploy<optional timestamp>.json`: Contains the template for the VM
3.  `<ServiceName>-<VMName>-parameters<optional timestamp>.json`: Contains the actual parameters passed to the templates
4.  `<ServiceName>-<VMName>-setextensions<optional timestamp>.json`: a set of PowerShell cmdlets to be run for setting the VM agent extensions.
4.  `<ServiceName>-<VMName>-copydisks<optional timestamp>.json`: a set of PowerShell cmdlets to be run for copying disk blobs, if CopyDisks option is specified.

If the -Deploy flag is set, after generating the files, the cmdlet then deploys the <ServiceName>-<VMName>-setup.json template, copies the source VM disk blobs if the DiskAction parameter is set to CopyDisks and then deploys the <ServiceName>-<VMName>-deploy.json template, using the <ServiceName>-<VMName>-parameters.json file for parameters. Once the deployment of the VM is done, if there is an imperative script (for VM agent extensions), or a script for copying the disks, they are executed.

### Network details
The cmdlet's intent is not to clone the ASM network settings to ARM. It utilizes the networking facilities in a way that is the most convenient for cloning the VM itself. Here is what happens on different conditions:

1.  No virtual network on the target resource group
    - Source VM is not on a subnet: A default virtual network with 10.0.0.0/16 is created along with a subnet, with 10.0.0.0/22 address space.
    - Source VM is on a subnet: The virtual network the VM is on is discovered, the specification of the virtual network, along with the subnets are copied over
2.  Target resource group has a virtual network with a name `<VM virtual network>arm` (the string 'arm' is appended)
    - If the virtual network has a subnet with the same name and address space, use it
    - If no suitable subnet is found, find an address block out of the existing subnets with 22 bits mask and use that one.

