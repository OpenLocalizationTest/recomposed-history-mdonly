---
title: Implementing Microsoft Sign-in on ASP.NET Web Server - Sign-In
description: How to  implement Microsoft Sign-In on a Visual Studio ASP.NET solution with a traditional web browser based application using OpenID Connect standard. | Microsoft Azure
services: active-directory
documentationcenter: dev-center-name
author: andretms
manager: mbaldwin
editor: ''

ms.assetid: 820acdb7-d316-4c3b-8de9-79df48ba3b06
ms.service: active-directory
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: identity
ms.date:
ms.author: andret

---

# Use MSAL to get a token for the Microsoft Graph API
1.	Add the reference for MSAL library to the class:

```csharp
using Microsoft.Identity.Client;
```

2.	Copy the code below and replace MainWindow class code with:

```csharp
public partial class MainWindow : Window
{
    //Set the API Endpoint to Graph 'me' endpoint
    string _graphAPIEndpoint = "https://graph.microsoft.com/v1.0/me";

    //Set the scope for API call to user.read
    string[] _scopes = new string[] { "user.read" };


    public MainWindow()
    {
        InitializeComponent();
    }

    /// <summary>
    /// Call AcquireTokenAsync - to acquire a token requiring user to sign-in
    /// </summary>
    private async void CallGraphButton_Click(object sender, RoutedEventArgs e)
    {
        AuthenticationResult authResult = null;

        try
        {
            if (authResult == null)
            {
                authResult = await App.PublicClientApp.AcquireTokenSilentAsync(_scopes, App.PublicClientApp.Users.FirstOrDefault());
            }
        }
        catch (MsalUiRequiredException ex)
        {
            // A MsalUiRequiredException happened on AcquireTokenSilentAsync. This indicates you need to call AcquireTokenAsync to acquire a token
            System.Diagnostics.Debug.WriteLine($"MsalUiRequiredException: {ex.Message}");

            try
            {
                authResult = await App.PublicClientApp.AcquireTokenAsync(_scopes);
            }
            catch (MsalException msalex)
            {
                ResultText.Text = $"Error Acquiring Token:{System.Environment.NewLine}{msalex}";
            }
        }
        catch (Exception ex)
        {
            ResultText.Text = $"Error Acquiring Token Silently:{System.Environment.NewLine}{ex}";
            return;
        }

        if (authResult != null)
        {
            ResultText.Text = await GetHttpContentWithToken(_graphAPIEndpoint, authResult.AccessToken);
            DisplayBasicTokenInfo(authResult);
            this.SignOutButton.Visibility = Visibility.Visible;
        }
    }
}
```
<!--start-collapse-->
### More Information
#### Getting a user token interactive
Calling `AcquireTokenAsync` method results on a window prompting user to sign-in. Applications usually require a user to sign-in interactively the first-time user needs to access a protected resource, or when a silent operation to acquire a token fails (e.g. user’s password expired)

#### Getting a user token silently
`AcquireTokenSilentAsync` handles token acquisitions and renewal without any user interaction. After `AcquireTokenAsync` is executed for the first time, `AcquireTokenSilentAsync`  is the usual method used to obtain tokens used to access protected resources for subsequent calls - as calls to request or renew tokens are made silently.
Eventually at one point, `AcquireTokenSilentAsync` will fail – e.g. user has signed off, or has changed password in another device. When MSAL detects that the issue can be resolved by requiring an interactive action, it fires an `MsalUiRequiredException`. Your application can then handle this exception two ways:

1.	Make a call against `AcquireTokenAsync` immediately, which results on prompting user to sign-in. This pattern is usually used on on-line applications where there is no offline content in the application available for the user. The sample generated by this guide setup uses this pattern: you can see it in action the first time you execute the sample: because no user ever used to the application, `PublicClientApp.Users.FirstOrDefault` will contain a null value, and a `MsalUiRequiredException` exception will be thrown. The code in the sample then handles the exception by calling `AcquireTokenAsync` resulting on prompting user to sign-in.

2.	Applications can also make a visual indication to the use that a sign-in interactive is required, so user can select the right time to sign-in, or the application can retry `AcquireTokenSilentAsync` on a later time. This is usually used when user can use other functionality of the application without being disrupted - for example, there is offline content available in the application. In this case, user then can decide when they want to sign-in to access the protected resource, or to refresh the outdated information, or your application can decide to retry `AcquireTokenSilentAsync` when network is restored after being unavailable temporarily.
<!--end-collapse-->

# Call the Microsoft Graph API using the token you just obtained

1. Add the new method below to your `MainWindow.cs`. The method is used to make a GET against Graph API using an Authorize header

```csharp
/// <summary>
/// Perform a HTTP GET to a URL using an HTTP Authorization header
/// </summary>
/// <param name="url">The URL</param>
/// <param name="token">The token</param>
/// <returns>String containing the results of the GET operation</returns>
public async Task<string> GetHttpContentWithToken(string url, string token)
{
    var httpClient = new System.Net.Http.HttpClient();
    System.Net.Http.HttpResponseMessage response;
    try
    {
        var request = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, url);
        //Add the token in Authorization header
        request.Headers.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", token);
        response = await httpClient.SendAsync(request);
        var content = await response.Content.ReadAsStringAsync();
        return content;
    }
    catch (Exception ex)
    {
        return ex.ToString();
    }
}
```
<!--start-collapse-->
### Making a REST call against a protected API

In this sample application, `GetHttpContentWithToken` makes a HTTP `GET` request against a resource that requires a token and return the content. This method adds the acquired token in the *HTTP Authorization header*. For this sample, the resource is the Microsoft Graph API *me* endpoint – which displays user profile’s information.
<!--end-collapse-->

# Setup Sign-out

1. Add the following additional method to sign-out the user:

```csharp
/// <summary>
/// Sign-Out the current user
/// </summary>
private void SignOutButton_Click(object sender, RoutedEventArgs e)
{
    if (App.PublicClientApp.Users.Any())
    {
        try
        {
            App.PublicClientApp.Remove(App.PublicClientApp.Users.FirstOrDefault());
            this.ResultText.Text = "User has signed-out";
            this.CallGraphButton.Visibility = Visibility.Visible;
            this.SignOutButton.Visibility = Visibility.Collapsed;
        }
        catch (MsalException ex)
        {
            ResultText.Text = $"Error signing-out user: {ex.Message}";
        }
    }
}
```
<!--start-collapse-->
### More info on Sign-Out

`SignOutButton_Click` removes the user from MSAL user cache – this will effectively tell MSAL to forget the current user so a future request to acquire a token will only succeed if it is made to be interactive.
Although the application in this sample is single-user, MSAL supports scenarios where multiple accounts can sign-in at the same time – an example is an email application where user has multiple accounts.
<!--end-collapse-->

## Display Basic Token Information

```csharp
/// <summary>
/// Display basic information contained in the token
/// </summary>
private void DisplayBasicTokenInfo(AuthenticationResult authResult)
{
    TokenInfoText.Text = "";
    if (authResult != null)
    {
        TokenInfoText.Text += $"Name: {authResult.User.Name}" + Environment.NewLine;
        TokenInfoText.Text += $"Username: {authResult.User.DisplayableId}" + Environment.NewLine;
        TokenInfoText.Text += $"Token Expires: {authResult.ExpiresOn.ToLocalTime()}" + Environment.NewLine;
        TokenInfoText.Text += $"Access Token: {authResult.AccessToken}" + Environment.NewLine;
    }
}
```
<!--start-collapse-->
### More Information

Tokens acquired via *OpenID Connect* also contain a small subset of information pertinent to the user. `DisplayBasicTokenInfo` displays basic information contained in the token: for example, the user display name and Id, as well as the token expiration date and the string representing the access token itself. This information is listed in the screen for your information. You can hit the *Call Microsoft Graph API* button multiple times and see that the same token was reused for subsequent requests. You can also see the expiration date being extended when MSAL decides it is time to renew the token.
<!--end-collapse-->

### What is Next

[Configure](active-directory-mobileanddesktop-windowsdesktop-configure.md)
