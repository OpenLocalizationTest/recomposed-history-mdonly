<properties
 pageTitle="Azure IoT Hub Developer guide messaging | Microsoft Azure"
 description="Describes how messaging works for device-to-cloud and cloud-to-device scenarios with Azure IoT Hub"
 services="azure-iot"
 documentationCenter=".net"
 authors="fsautomata"
 manager="timlt"
 editor=""/>

<tags
 ms.service="azure-iot"
 ms.devlang="na"
 ms.topic="article"
 ms.tgt_pltfrm="na"
 ms.workload="tbd"
 ms.date="09/04/2015"
 ms.author="dobett"/>

# Azure IoT Hub developer guide - messaging
Azure IoT Hub provides messaging primitives to communicate from an application back-end (*service* or *cloud*) to devices, and vice-versa. We refer to these functionalities as [Device-to-Cloud][lnk-d2c] or *D2C*, [Cloud-to-Device][lnk-c2d] or *C2D*.

Core properties of IoT Hub messaging functionality are the reliability and durability of messages. This enables resilience to intermittent connectivity on the device side, and to load spikes in event processing. IoT Hub implements *at least once* delivery guarantees for both D2C and C2D messaging.

IoT Hub supports multiple device-facing protocols (such as AMQP and HTTP/1). In order to support seamless interoperability across protocols, IoT Hub defines a common message format that is supported by all device-facing protocols.

## Message format
IoT Hub messages comprise:

* A set of *system properties*. These are properties that are interpreted or set by IoT Hub. This set is predetermined.
* A set of *application properties*. This is an immutable dictionary of string properties that the application can define and access without having to deserialize the body.
* An opaque binary body.

Refer to [IoT Hub APIs and SDKs][lnk-apis-sdks] for more information on how the message is encoded in different protocols.

This is the set of system properties in IoT Hub messages.

| Property | Description |
| -------- | ----------- |
| MessageId | A user-set identifier for the message, usually used for request-reply patterns. Format: A case-sensitive string (up to 128 char long) of ASCII 7-bit alphanumeric chars + `{'-', ':',â€™.', '+', '%', '_', '#', '*', '?', '!', '(', ')', ',', '=', '@', ';', '$', '''}`. |
| Sequence number | A number (unique per device-queue) assigned by IoT Hub to each C2D message. |
| To | Used in [Cloud-to-Device][lnk-c2d] for the destination of the message.|
| ExpiryTimeUtc | Date and time of expiration of the message. |
| EnqueuedTime | Time when the message was received by IoT Hub. |
| CorrelationId | String property usually containing the message id of the request in request-reply patterns. |
| UserId | Used to specify the origin of messages. When messages are generated by IoT Hub, it is set to `{iot hub name}`. |
| Ack | Used in C2D messages to request IoT Hub to generate feedback messages as a result of the consumption of the message by the device. Possible values: `none` (default): no feedback message is generated, `positive`: receive a feedback message if the message was completed, `negative`: receive a feedback message if the message expired (or max delivery count was reached) without being completed by the device, `full`: both positive and negative. For more information refer to [Message feedback](#message-feedback). |
| ConnectionDeviceId | Set by IoT Hub on D2C messages. It contains the deviceId of the device that sent the message. |
| ConnectionDeviceGenerationId | Set by IoT Hub on D2C messages. It contains the generationId (as per [Device identity properties]([lnk-device-identity-properties]) of the device that sent the message. |
| ConnectionAuthMethod | Set by IoT Hub on D2C messages. Information about the authentication method used to authenticate the device sending the message. Refer to [D2C anti-spoofing](#antispoofing) for more information.|

## Device to cloud <a id="d2c"></a>
As detailed in the [Endpoints][lnk-endpoints] section, device-to-cloud messages are sent through a device-facing endpoint (in particular `/devices/{deviceId}/messages/events`), and received through a service-facing endpoint (`/messages/events`), that is compatible with [Event Hubs][lnk-event-hubs]. Therefore, you can use standard Event Hubs integration and SDKs to receive messages.

Azure IoT Hub implements D2C messaging in a way that is very similar to [Event Hubs][lnk-event-hubs], with IoT Hub's D2C messages being more similar to Event Hubs' *events* than to [Service Bus][lnk-servicebus] *messages*.
This has the following implications:

1. Similarly to Event Hubs *events*, device-to-cloud messages are durable and retained in an IoT hub for up to 7 days (refer to [D2C configuration options](#d2cconfiguration)).
2. D2C messages are partitioned in a fixed set of partitions that is set at creation time (refer to [D2C configuration options](#d2cconfiguration)).
3. Analogously to Event Hubs, clients reading D2C messages have to handle partitions and checkpointing, see [Event Hubs - Consuming events].
4. Like Event Hubs' events, D2C messages can be at most 256Kb, and can be grouped in batches to optimize sends.

There are, however, a few important distinctions between IoT Hub's D2C and Event Hubs:

* As explained in the [Security][lnk-security] section, IoT Hub allows per-device authentication and access control,
* IoT Hub allows millions of simultaneously connected devices (see [Quotas and throttling][lnk-throttling]), while Event Hubs is limited to 5000 AMQP connections per namespace.
* IoT Hub does not allow arbitrary partitioning using a `PartitionKey`. D2C messages are partitioned with respect to their originating `deviceId`.
* Scaling IoT Hub is slightly different than Event Hubs, refer to the [Scale][lnk-guidance-scale] section of Azure IoT Hub Guidance for more information.

Note that the above does not mean that IoT Hub substitutes Event Hubs in all scenarios. For instance, in some event processing computations, it might be required to repartition events with respect to a different property or field before analyzing the data streams. In that case an event hub could be used to decouple two portions of the stream processing pipeline.

Please, refer to [Azure IoT Reference Architecture] for more information on how to perform event processing for IoT solutions in Azure.

Finally, for details on how to use D2C messaging refer to [IoT Hub APIs and SDKs][lnk-apis-sdks].

### Non-telemetry traffic
In many cases, devices are sending not only telemetry data points to the application back-end, but also *interactive* messages and requests that require execution and handling from the application business logic layer. Good examples are critical alerts that have to trigger a specific action in the back-end, or device replies to commands.

Please refer to the [D2C processing][lnk-guidance-d2c-processing] section of the IoT Hub Guidance for more information on the best way to process this kind of messages.

### D2C configuration options <a id="d2cconfiguration"></a>
An IoT Hub exposes the following properties to control D2C messaging.

* **Partition count**. This property can be set at creation and defines the number of partitions for D2C event ingestion.
* **Retention time**. This property specifies the retention time for D2C messages. It defaults to 1 day, but it can be increased up to 7.

Also, analogously to Event Hubs, IoT Hub allows the management of Consumer Groups on the D2C receive endpoint.

All the properties above can be modified both through the [Azure Management Portal][lnk-management-portal], or programmatically through [Azure IoT Hub - Resource Provider APIs][lnk-resource-provider-apis].

### Anti-spoofing properties <a id="antispoofing"></a>
In order to avoid device spoofing in D2C messages, IoT Hub stamps all messages with the following properties:

* **ConnectionDeviceId**
* **ConnectionDeviceGenerationId**
* **ConnectionAuthMethod**

The first two contain the **deviceId** and **generationId** of the originating device, as per [Device identity properties][lnk-device-identity-properties].
The **ConnectionAuthMethod** property contains a JSON serialized object with the following properties:

    {
        "scope": "{ hub | device}",
        "type": "{ symkey | sas}",
        "issuer": "iothub"
    }

## Cloud to device <a id="c2d"></a>
As already detailed in the [Endpoints][lnk-endpoints] section, cloud-to-device messages are sent through a service-facing endpoint (`/messages/devicebound`), and received through a series device-facing endpoins (`/devices/{deviceId}/messages/devicebound`).

Each cloud-to-device message is targeted at a single device, setting the **to** property to `/devices/{deviceId}/messages/devicebound`.

**Important**: Each device queue can hold at most 50 cloud-to-device messages. Trying to send more messages to the same device will result in an error.

### Message lifecycle <a id="message lifecycle"></a>
In order to implement *at least once* delivery guarantee, cloud-to-device messages are persisted in per-device queues, and devices have to explicitly acknowledge *completion* for IoT Hub being able to remove them from the queue. This guarantees resiliency against connectivity and device failures.

The following picture details the lifecycle state graph for a cloud-to-device message.

![Cloud-to-device message lifecycle][img-lifecycle]

When a message is sent by the service, it is considered *Enqueued*. When a device wants to *receive* a message, IoT Hub *locks* the message (state **Invisible**), in order to allow other threads on the same device to start receiving other messages. When a device thread has completed the processing of a device, it notifies IoT Hub by *completing* the message. It can also decide to *reject* the message, which sends it to **Deadlettered** state, or *abandon* which puts the message back in the queue (state **Enqueued**).

Since a thread could fail to process a message without notifying IoT Hub, messages will automatically transition from **Invisible** back to **Enqueued** after a *visibility (or lock) timeout*. A message can transition between **Enqueued** and **Invisible** states for at most a specified number of times specified in the *max delivery count* property on IoT Hub. After that number of transitions, the message will automatically deadlettered. Similarly, a message will be automatically deadlettered after its expiration time (refer to [Time to live](#ttl)).

Refer to [Get started with Azure IoT Hub cloud-to-device messages][lnk-getstarted-c2d-tutorial] for a tutorial on cloud-to-device messages, and to [IoT Hub APIs and SDKs][lnk-apis-sdks] for references on how different APIs and SDKs expose the cloud-to-device functionality.

**Note**: Typically, cloud-to-device messages should be completed whenever the loss of the message would not affect the application logic. This could happen in many different scenarios, for instance: the message content has been successfully persisted on local storage, or an operation has been successfully executed, or the message is carrying transient information whose loss would not impact the functionality of the application. Sometimes, for long running tasks, it is common to complete the cloud-to-device message after having persistent the task description on local storage, and then notify the application back-end with one or more device-to-cloud message at various stages of progress of the task.

### Time to live <a id="ttl"></a>
Every cloud-to-device message has an expiration time. This can be explicitly set by the service (in the **ExpiryTimeUtc** property), or it is set by IoT Hub using the default time to live specified as an IoT Hub property, see [Cloud-to-device configuration options](#c2dconfiguration).

### Message feedback
When sending a cloud-to-device message, the service can request the delivery of a per-message feedback regarding the final state of that message. When setting the **Ack** property to **positive**, IoT Hub will generate a feedback message if and only if the cloud-to-device message reached the **Completed** state. By setting the **Ack** property to **negative**, IoT Hub will generate a feedback message if and only if the cloud-to-device message reaches the **Deadletterd** state. By setting the **Ack** property to **full**, IoT Hub will generate a feedback message in either case.

As detailed in [Endpoints][lnk-endpoints], feedback is delivered through a service-facing endpoint (`/messages/servicebound/feedback`) as messages. The receive semantics for feedback is the same as for cloud-to-device messages with the same [Message lifecycle](#message lifecycle). Whenever possible, message feedback is batched in a single message, with the following format.

Each message retrieved from the feedback endpoint has the following properties.

| Property | Description |
| -------- | ----------- |
| EnqueuedTime | Timestamp of when the batch was created. |
| UserId | `{iot hub name}` |
| ContentType | `application/vnd.microsoft.iothub.feedback.json` |

The body is a JSON-serialized array of records, each with the following properties:

| Property | Description |
| -------- | ----------- |
| EnqueuedTime | Timestamp of when the outcome of the message happened. For example, the device completed or the message expired. |
| CorrelationId | **MessageId** of the cloud-to-device message to which this feedback information pertains. |
| StatusCode | **0** if success, **1** if the message expired, **2** if the maximum delivery count is exceeded, **3** if the message was rejected. |
| Description | String values for the above outcomes. |
| DeviceId | **DeviceId** of the target device of the cloud-to-device message to which this piece of feedback pertains. |
| DeviceGenerationId | **DeviceGenerationId** of the target device of the cloud-to-device message to which this piece of feedback pertains. |

**Important**. The service has to specify a **MessageId** for the cloud-to-device message in order to be able to correlate its feedback with the original message.

**Example**. Here is an example body of a feedback message.

    [
        {
            "CorrelationId": "0987654321",
            "EnqueuedTime": "2015-07-28T16:24:48.789Z",
            "StatusCode": "0",
            "Description": "Success",
            "DeviceId": "123",
            "DeviceGenerationId": "abcdefghijklmnopqrstuvwxyz"
        },
        {
            ...
        },
        ...
    ]

### Cloud-to-device configuration options <a id="c2dconfiguration"></a>
Each IoT hub exposes the following configuration options for cloud-to-device messaging.

| Property | Description | Range and default |
| -------- | ----------- | ----------------- |
| defaultTtlAsIso8601 | Default TTL for cloud-to-device messages. | ISO_8601 interval up to 2D (minimum 1 minute). Default: 1 hour. |
| maxDeliveryCount | Maximum delivery count for cloud-to-device per-device queues. | 1 to 100. Default: 10. |
| feedback.ttlAsIso8601 | Retention for service-bound feedback messages. | ISO_8601 interval up to 2D (minimum 1 minute). Default: 1 hour. |
| feedback.maxDeliveryCount | Maximum delivery count for feedback queue. | 1 to 100. Default: 100. |

[img-lifecycle]: media/iot-hub-devguide-messaging/lifecycle.png
[lnk-d2c]: iot-hub-devguide-messaging.md#d2c
[lnk-c2d]: iot-hub-devguide-messaging.md#c2d
[lnk-apis-sdks]: TBD
[lnk-device-identity-properties]: iot-hub-devguide-registry.md#deviceproperties
[lnk-endpoints]: iot-hub-devguide-endpoints.md
[lnk-event-hubs]: http://azure.microsoft.com/en-us/services/event-hubs/
[lnk-servicebus]: http://azure.microsoft.com/en-us/services/service-bus/
[lnk-security]: iot-hub-devguide-security.md
[lnk-throttling]: iot-hub-devguide-intro.md#throttling
[lnk-guidance-scale]: TBD
[lnk-guidance-d2c-processing]: TBD
[lnk-management-portal]: https://portal.azure.com
[lnk-resource-provider-apis]: TBD
[lnk-getstarted-c2d-tutorial]: TBD
