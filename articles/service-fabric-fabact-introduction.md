<properties
   pageTitle="Azure Service Fabric Actors Overview"
   description="Introduction to Azure Service Fabric Actors programming model"
   services="service-fabric"
   documentationCenter=".net"
   authors="jessebenson"
   manager="timlt"
   editor=""/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="03/02/2015"
   ms.author="claudioc"/>

# Introduction to Azure Service Fabric Actors
Azure Service Fabric Actors is an Actor programming model for Service Fabric. Service Fabric is a platform for building highly reliable, scalable applications for both cloud and on premise that are easy to develop and manage.

Fabric Actors provides an asynchronous, single-threaded actor model. The actors represents the unit of state and computation that are distributed throughout the cluster to achieve high scalability. When the actor processes or the nodes on which they are hosted fails, the system recreates them on different node or processes. The framework leverages the distributed store provided by underlying Service Fabric platform to provide highly available and consistent state management for the application developers. This makes developing and maintaining distributed cloud applications extremely easy.

## Actors
The Actors are isolated single-threaded components that encapsulate both state and behavior. They are similar to .NET objects and hence provides a natural programming model to the developers. Actors interacts with rest of the system, including other actors by passing asynchronous messages with request-response pattern. These interactions are defined in an interface as asynchronous methods. Actors implementing these methods do not have to deal with locking or other concurrency issues as the framework provides a turn based concurrency for the actor methods. This means that not more than one thread will be active at any time inside the actor methods.

The actors in Fabric Actors are virtual actors meaning that they always exists. You do not need to explicitly create them nor destroy them. The framework along with the underlying platform provides the location transparency and failover for the actors. If an actor is not used for certain time the framework will garbage collect it and will recreate it at later time if required.

## Concurrency
Actor framework provides a simple turn based concurrency for actor methods. This means that no more than one thread can be active inside the actor method any time. The framework can provide this guarantees for the methods invocations that are done in response to receiving a message, timer callback or reminder callback. If the actor code creates a Task that is not associated with the Task returned by the actor methods or it creates a thread, the framework cannot provide any guarantees with respect to the concurrency of those executions. To perform a background operation, please use [Actor Timers or Actor Reminders](service-fabric-fabact-timers-reminders.md) that respect the turn based concurrency.

Please note that a turn consistent complete execution of an actor method in response to the request from other actors or clients, or a timer / reminder callback. Even though these methods and callback are asynchronous. there is no interleaving. A turn must be completed fully before a new call is allowed.

The framework however, allows reentrancy by default. This means that if an actor method of Actor A calls method on Actor B which in turn calls another method on actor A, that method is allowed to run as it is part of the same logical call chain context. All timer and reminder calls start with the new logical call context. See [Actor Reentrancy](service-fabric-fabact-reentrancy.md) for more details.

## Actors and Service Fabric Services
Every Actor type is mapped to a Service Fabric Service which is partitioned based on the int64 keys. The number of partitions for a service can be specified in the ApplicationManifest.xml generated by FabActUtil.exe. Each partition of the service can have one or more replica depending upon the state provider used as well as settings in the ApplicationManifest.xml. The platform places the replicas of various partition on different nodes available in the cluster. These partitions run inside the Code that hosts the service and hence the Actors. This is the executable that registers the Actor implementations with Service Fabric runtime.

The partitions provides automatic scaling for your applications whereas the replicas provides reliability for the state. As you add more nodes the resource manager of Service Fabric will spread out the partition to utilize the cluster resources more effectively. The resource manager optimizes the placement based on the available fault and upgrade domains in the cluster. Note that two replicas of the same partition are never placed in on the same node.

## Actor State Management
Fabric Actors allows you to create the actors that are either stateless or stateful.

### Stateless Actors
Stateless actors, as the name suggests do not have the state that is managed by the framework. The stateless actors derive from Actor base class. They can have member variables and those would be preserved throughout the lifetime of that actor just like any other .NET types. However if that actor instance is garbage collected after being idle for some time it would lose the state stored in its member variables. Similarly if the actor process or the node fails it would lose the state stored in its member variables as well.

Following is an example of a stateless actor.
```csharp
class HelloActor : Actor, IHello
{
    public Task<string> SayHello(string greeting)
    {
        return Task.FromResult("You said: '" + greeting + "', I say: Hello Actors!");
    }
}
```

### Stateful Actors
Stateful  actors have a state that needs to be preserved across activation and failovers. The stateful actors derive from Actor<TState> base class where TState is the type of the state that needs to be preserved across activations and failovers. The state can be accessed in the actor methods via State property on the base class Actor<TState>.  Following is an example of a stateful actor accessing the state.
```csharp
class VoicemailBoxActor : Actor<VoicemailBox>, IVoicemailBoxActor
{
    public Task<List<Voicemail>> GetMessagesAsync()
    {
        return Task.FromResult(State.MessageList);
    }

    ...
}
```
The storage and retrieval of the state is provided by an actor state provider. There are few default actor state providers that are included in the framework. The durability and reliability of the state is determined by the guarantees offered by the state provider. When an actor is activated its State is loaded in memory. Once the actor method returns modified state is automatically saved by the framework by calling a method on the state provider. If failure occurs during the save state, the framework recycles that actor instance. A new actor instance is created and loaded with the last consistent data from the state provider.

State provider can be configured per actor or for all actors within an assembly by the state provider specific attribute. By default a stateful actor uses key value store actor state provider. This state provider is built on the distributed Key-Value store provided by Service Fabric platform. The state is durably saved on the local disk as well as replicated and durably saved on secondary replicas as well. The state save is complete only when a quorum of replicas has committed the state to their local disks. The Key-Value store has advance capabilities to detect inconsistencies such as false progress and correct them automatically. More details on the KvsActorStateProvider can be found here.

The framework also includes a VolatileActorStateProvider. This state provider replicates the state to replicas but the state remains in-memory on the replica. If one replica goes down and comes back up, its state is rebuilt from the other replica. However if all of the replicas (copies of the state) go down simultaneously the state data will be lost. This state provider is suitable for applications where the data can survive failures of few replicas and can survive the planned failovers such as upgrades, but can be recreated if all  replicas (copies) are lost. You can configure your stateful actor to use volatile actor state provider by adding the following attribute to the actor class or an assembly level attribute.

The following code snippet shows how to changes all actors in the assembly that does not have an explicit state provider attribute to use VolatileActorStateProvider.

```csharp
[assembly:Microsoft.ServiceFabric.Actors.VolatileActorStateProvider]
```

The following code snippet shows how to change the state provider for a particular actor, VoicemailBox in this case to be VolatileActorStateProvider.

```csharp
[VolatileActorStateProvider]
public class VoicemailBoxActor : Actor<VoicemailBox>, IVoicemailBoxActor
{
    public Task<List<Voicemail>> GetMessagesAsync()
    {
        return Task.FromResult(State.MessageList);
    }
Â 
    ...
}
```

Please note that changing the state provider requires the actor service to be recreated. State providers cannot be changed as part of the application upgrade.

### Readonly Methods
By default the framework saves Actor state upon exiting from an actor method call, timer callback and reminder callback. No other actor call is allowed until the save state is complete.  Depending upon the state provider, saving state may take time and during this time no other actor methods are being allowed in the actor. For example, the default KvsActorStateProvider replicates the data to a replica set and only when a quorum of replicas have committed the data to a persisted store, the save state is completed.

There may be actor methods that do not modify the state. In that case the additional time spent on saving the state can affect the overall throughput of the system. To avoid that you can mark the methods and timer callback that do not modify the state as Readonly.

The example below shows how to mark an actor method as readonly using Readonly attribute.
```csharp
public interface IVoicemailBoxActor : IActor
{
    [Readonly]
    Task<List<Voicemail>> GetMessagesAsync();
}
```
Similarly you can pass Readonly flag when registering a timer or reminder.

## Actor Communication
The actor framework provides communication between the actor instance and the actor client. The framework also provides the location transparency and failover. The ActorProxy class on the client side perform the necessary resolution and locates the actor service partition where the actor with the specified id is hosted and opens a communication channel with it. The ActorProxy retries on the communication failures and in case of failovers.  This does mean that it is possible for an Actor implementation to get duplicate messages from the same client.  ActorProxy should be used for client to Actor as well as Actor to Actor communication.

The code snippet below shows the example of creating the ActorProxy to communicate to the actor that implements IHelloWorld actor interface.

```csharp
var friend = ActorProxy.Create<IHello>(ActorId.GetRandom(), ApplicationName);

Console.WriteLine("\n\nFrom Actor {1}: {0}\n\n", friend.SayHello("Good morning!").Result, friend.GetActorId());

```

## See Also
### Concepts
[Actor Lifecycle and Garbage Collection](service-fabric-fabact-lifecycle.md)

[Actor Timers & Reminders](service-fabric-fabact-timers-reminders.md)

[Actor Events](service-fabric-fabact-events.md)

[Actor Reentrancy](service-fabric-fabact-reentrancy.md)
